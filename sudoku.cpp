#include <iostream>
#include <math.h>
#define MAXITERATIONS 100
// DEBUG LEVELS
// 0 Just Solve
// 1 Show Rules Triggered
// 2 Dev Debug
// 3 Special
// 4 Just Numbers (puzzle)
// 5 Just Numbers (solution)
// 10 ARRAY
#define DEBUG 1
using namespace std;
int state=0;
int _oldstate=0;
int statecount=0;
float score=0;
float startscore=0;

class cell
{
public:
  void xwingRedux();
  void trioOfPairs();
  void trioOfTrios();
  void setValue(int);
  int getValue();
  int checkRow(); // removes any setvalues from the list of couldbes in a row
  int checkColumn(); // removes any setvalues from the list of couldbes in a column
  int checkGroup(); // removes any setvalues from the list of couldbes in a group
  int howManyCouldBes(); // returns the number of couldbes for a cell
  int maxCouldBe(); // returns the greatest couldbe for a cell
  int minCouldBe(); // returns the least couldbe for a cell
  void initCouldBes();
  void cantBe(int);
  void setRC(int, int);
  void setGroup(int);
  int getGroup();
  int couldIBe(int);
  void soleCouldBe(); // if there's only one could be, this set the value of the cell to it
  void emptyRectangle();
  
  void noFourthCorner();

  void pairs();
  
  void exclusion();
  void dumpCouldBes();
  void lonely();
  void uniqueInRow();
  void uniqueInColumn();
  void uniqueInGroup();
  int isPair();
  void boxLineRedux();
  // Location
  int value;
  int myrow;
  int mycol;

  int couldBe[9];
  int mySubGroup; // which group 1->9
  int startrow; // for groups 1->9
  int startcol; // for groups 1->9
};

cell puzzle[9][9];

// ENTER YOUR SUDOKU HERE
// Error in Puzzle?
int P[9][9]={ {0,0,1,0,0,3,0,7,8},{0,8,7,0,1,6,0,2,3},{0,0,3,7,0,8,6,0,1},{7,0,0,1,3,0,0,8,0},{3,2,8,0,7,0,1,0,0},{1,0,0,0,8,5,0,3,7},{0,1,0,8,0,7,3,0,0},{8,3,0,2,4,0,7,1,0},{0,7,9,3,0,1,8,0,0}};
//int P[9][9]={ {0,0,5,0,3,0,0,0,0},{0,1,0,0,0,6,0,2,0},{4,0,0,0,0,9,6,0,0},{0,0,0,0,0,0,4,5,0},{1,0,0,0,9,0,0,0,8},{0,4,9,0,0,0,0,0,0},{0,0,2,8,0,0,0,0,3},{0,6,0,5,0,0,0,4,0},{0,0,0,0,7,0,2,0,0}};

// SOLVED 8 - 32% -> 100%
//int P[9][9]={{0,0,0,2,3,0,0,0,0},{0,5,0,8,0,1,0,4,0},{1,0,0,0,0,7,0,0,2},{5,0,0,0,0,0,9,0,0},{0,0,0,0,0,0,8,2,0},{0,8,0,1,0,2,0,7,0},{0,0,0,0,0,0,0,0,0},{2,0,4,3,0,0,6,9,0},{6,0,0,0,9,0,0,0,1}};

// Diabolical (DSY) 36% -> 52%
//int P[9][9]={{0,9,0,7,0,0,8,6,0},{0,3,1,0,0,5,0,2,0},{8,0,6,0,0,0,0,0,0},{0,0,7,0,5,0,0,0,6},{0,0,0,3,0,7,0,0,0},{5,0,0,0,1,0,7,0,0},{0,0,0,0,0,0,1,0,9},{0,2,0,6,0,0,3,5,0},{0,5,4,0,0,8,0,7,0}};

// Rated 11 - 26% -> 26%
// http://www.conceptispuzzles.com/index.aspx?uri=info/article/424
//int P[9][9]={{8,0,0,0,0,0,0,0,0},{0,0,3,6,0,0,0,0,0},{0,7,0,0,9,0,2,0,0},{0,5,0,0,0,7,0,0,0},{0,0,0,0,4,5,7,0,0},{0,0,0,1,0,0,0,3,0},{0,0,1,0,0,0,0,6,8},{0,0,8,5,0,0,0,1,0},{0,9,0,0,0,0,4,0,0}};

// Evil - DSY - 35% -> 46%
//int P[9][9]={{5,0,0,0,6,0,0,0,4},{0,0,1,2,0,5,6,0,0},{0,7,0,0,0,0,0,3,0},{0,1,0,9,0,7,0,6,0},{9,0,0,0,0,0,0,0,1},{0,2,0,4,0,6,0,9,0},{0,3,0,0,0,0,0,4,0},{0,0,7,5,0,9,2,0,0},{4,0,0,0,3,0,0,0,6}};

// Excessive - DSY - 32% -> 46%
//int P[9][9]={{0,0,3,0,0,0,8,0,0},{0,9,0,2,0,1,0,4,0},{8,0,0,0,0,0,0,0,2},{0,5,0,8,0,6,0,1,0},{0,0,0,0,1,0,0,0,0},{0,2,0,7,0,9,0,8,0},{9,0,0,0,0,0,0,0,7},{0,1,0,6,0,5,0,9,0},{0,0,2,0,0,0,5,0,0}};

// Extreme - DSY - 32% -> 42%
//int P[9][9]={{0,0,6,0,0,0,8,0,0},{0,2,0,1,0,9,0,4,0},{9,0,0,0,0,0,0,0,7},{0,1,0,2,0,7,0,9,0},{0,0,0,0,4,0,0,0,0},{0,4,0,3,0,6,0,8,0},{8,0,0,0,0,0,0,0,2},{0,9,0,6,0,1,0,3,0},{0,0,7,0,0,0,5,0,0}};
// ==========================================

// A 17-Clue Puzzle - SOLVED 8 22% -> 100%
//int P[9][9]={{0,0,0,7,0,0,0,0,0},{1,0,0,0,0,0,0,0,0},{0,0,0,4,3,0,2,0,0},{0,0,0,0,0,0,0,0,6},{0,0,0,5,0,9,0,0,0},{0,0,0,0,0,0,4,1,8},{0,0,0,0,8,1,0,0,0},{0,0,2,0,0,0,0,5,0},{0,4,0,0,0,0,3,0,0}};

// DIFFICULT - SOLVED 5 31% -> 100%
//int P[9][9]={{7,0,0,0,0,0,2,0,6},{0,4,0,7,0,0,0,0,0},{0,0,0,4,0,0,5,1,7},{0,0,0,2,0,0,0,0,9},{2,0,0,0,9,0,0,0,5},{4,0,0,0,0,7,0,0,0},{5,7,9,0,0,3,0,0,0},{0,0,0,0,0,1,0,7,0},{3,0,1,0,0,0,0,0,8}};

// EVIL - SOLVED 7
//int P[9][9]={{2,6,3,0,0,0,0,0,0},{0,0,0,5,0,0,0,0,1},{0,0,7,0,0,0,0,0,0},{0,0,0,0,3,0,7,0,0},{1,0,0,4,0,0,0,0,0},{0,0,0,0,0,0,0,5,0},{6,4,0,1,0,0,0,0,0},{0,0,0,0,0,0,3,7,0},{0,0,0,0,0,0,8,0,0}};

// Looks Hard - SOLVED 7
//int P[9][9]={{0,0,6,7,0,3,5,0,0},{0,0,0,0,4,0,0,0,0},{5,0,0,0,0,0,0,0,2},{9,0,0,0,0,0,0,0,7},{0,3,0,0,0,0,0,4,0},{8,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,4},{0,0,0,0,0,0,0,0,0},{0,5,9,2,6,7,3,1,0}};

// **** SOLVED 6
//int P[9][9]={{0,0,3,2,0,0,8,0,0},{0,9,0,0,0,5,1,6,0},{0,0,0,0,0,0,0,0,0},{0,4,0,0,0,0,0,8,2},{9,0,0,8,0,6,0,0,5},{6,2,0,0,0,0,0,7,0},{0,0,0,0,0,0,0,0,0},{0,1,5,9,0,0,0,2,0},{0,0,4,0,0,1,3,0,0}};

// EVIL SOLVED 6 [noFourthCorner]
//int P[9][9]={{0,7,9,0,0,6,0,0,0},{1,0,0,0,0,0,0,0,0},{0,0,4,3,1,0,0,5,0},{0,0,0,0,0,0,0,6,5},{9,0,0,5,0,8,0,0,1},{7,3,0,0,0,0,0,0,0},{0,8,0,0,4,9,3,0,0},{0,0,0,0,0,0,0,0,9},{0,0,0,1,0,0,6,7,0}};

// *** SOLVED 4
//int P[9][9]={{4,0,0,0,0,0,2,0,8},{0,3,0,0,6,0,0,9,0},{9,0,0,1,0,3,0,0,0},{0,0,8,0,0,0,9,0,0},{0,4,0,0,3,0,0,7,0},{0,0,1,0,0,0,6,0,0},{0,0,0,4,0,8,0,0,1},{0,6,0,0,1,0,0,5,0},{1,0,9,0,0,0,0,0,2}};

// **** SOLVED 5
//int P[9][9]={{0,0,1,0,0,8,0,4,0},{0,0,0,5,6,0,0,0,8},{2,0,0,0,0,0,9,0,0},{0,7,0,0,0,9,0,0,5},{0,6,0,0,0,0,0,2,0},{1,0,0,6,0,0,0,9,0},{0,0,5,0,0,0,0,0,6},{9,0,0,0,7,3,0,0,0},{0,8,0,1,0,0,2,0,0}}; 

// MYSTERY SOLVED 3
//int P[9][9]={{6,4,8,3,7,0,0,0,2},{9,0,0,6,0,5,0,3,0},{7,0,0,2,0,4,0,0,8},{2,0,0,0,0,7,0,4,0},{8,5,1,4,3,0,0,0,9},{4,7,0,0,0,8,0,5,6},{3,9,0,0,0,2,0,0,4},{5,0,0,9,0,1,0,8,0},{1,8,6,7,4,0,0,0,5}};

// MYSTERY SOLVED 2
//int P[9][9]={{6,4,8,3,7,9,5,1,2},{9,0,0,6,0,0,0,0,7},{7,0,5,2,1,4,6,0,8},{2,0,3,0,0,0,8,0,1},{8,5,1,0,3,0,2,0,9},{4,0,9,0,0,0,3,5,6},{3,0,7,8,5,2,1,0,4},{5,0,0,0,0,0,0,0,3},{1,8,6,7,4,3,9,2,5}};

// ???? SOLVED 5
//int P[9][9]={{0,1,0,0,0,0,0,0,0},{5,7,6,0,0,0,8,0,0},{0,0,0,0,9,5,0,0,6},{0,0,0,0,3,6,0,9,2},{0,4,0,7,0,2,0,6,0},{2,6,0,1,4,0,0,0,0},{1,0,0,4,6,0,0,0,0},{0,0,5,0,0,0,6,1,4},{0,0,0,0,0,0,0,8,0}};

// **** SOLVED 7 [noFourthCorner] 5
//int P[9][9]={{0,4,0,0,7,0,0,1,0},{9,0,0,6,8,5,0,0,7},{0,0,0,0,0,0,0,0,0},{0,6,0,0,9,0,0,4,0},{8,5,0,0,0,0,0,7,9},{0,7,0,0,2,0,0,5,0},{0,0,0,0,0,0,0,0,0},{5,0,0,9,6,1,0,0,3},{0,8,0,0,4,0,0,2,0}};

// SOLVED 0
//int P[9][9]={{6,4,8,3,7,9,5,1,2},{9,1,2,6,8,5,4,3,7},{7,3,5,2,1,4,6,9,8},{2,6,3,5,9,7,8,4,1},{8,5,1,4,3,6,2,7,9},{4,7,9,1,2,8,3,5,6},{3,9,7,8,5,2,1,6,4},{5,2,4,9,6,1,7,8,3},{1,8,6,7,4,3,9,2,5}};

// **** SOLVED 6
//int P[9][9]={{0,0,4,0,0,0,5,0,0},{3,5,0,0,0,0,0,2,1},{0,0,0,2,0,9,0,0,0},{6,0,0,0,0,0,0,0,3},{0,0,0,3,6,1,0,0,0},{5,0,0,0,0,0,0,0,8},{0,0,0,6,0,8,0,0,0},{2,4,0,0,0,0,0,3,7},{0,0,8,0,0,0,4,0,0}};

// ** SOLVED 3
//int P[9][9]={{0,0,0,0,9,0,0,7,0},{0,0,4,0,0,0,3,0,1},{0,2,0,7,5,0,0,8,0},{0,0,9,0,0,5,0,0,0},{1,0,5,0,0,0,8,0,3},{0,0,0,2,0,0,9,0,0},{0,4,0,0,8,3,0,9,0},{8,0,6,0,0,0,4,0,0},{0,9,0,0,1,0,0,0,0}};

// ???? SOLVED 5
//int P[9][9]={{4,0,0,0,0,0,0,0,0},{0,0,5,2,0,3,0,7,0},{0,6,3,7,0,9,0,0,5},{0,0,0,4,0,0,3,0,9},{0,0,0,1,0,5,0,0,0},{7,0,9,0,0,8,0,0,0},{8,0,0,9,0,2,6,5,0},{0,2,0,3,0,6,1,0,0},{0,0,0,0,0,0,0,0,8}};

// **** SOLVED 6
//int P[9][9]={{0,7,0,0,0,0,0,9,0},{2,9,0,7,0,0,1,0,0},{0,0,0,0,0,8,0,0,0},{0,6,9,0,0,4,0,0,2},{5,2,0,0,0,0,0,8,7},{1,0,0,8,0,0,4,5,0},{0,0,0,2,0,0,0,0,0},{0,0,1,0,0,9,0,6,5},{0,8,0,0,0,0,0,4,0}};

// **** SOLVED 4
//int P[9][9]={{0,7,0,0,9,4,0,0,0},{0,0,8,0,0,0,1,0,5},{0,4,0,0,0,0,0,3,0},{8,0,0,5,0,1,0,0,0},{6,0,0,0,0,0,0,0,4},{0,0,0,2,0,7,0,0,3},{0,6,0,0,0,0,0,2,0},{1,0,9,0,0,0,7,0,0},{0,0,0,6,5,0,0,8,0}};

// ???? SOLVED 6
//int P[9][9]={{0,0,0,6,0,0,3,0,0},{0,0,0,0,1,0,0,0,0},{0,3,9,0,4,0,0,7,8},{0,1,0,4,0,0,0,0,7},{7,8,0,0,0,0,0,3,5},{4,0,0,0,0,5,0,1,0},{6,7,0,0,8,0,9,5,0},{0,0,0,0,2,0,0,0,0},{0,0,8,0,0,4,0,0,0}};

// **** SOLVED 6 [noFourthCorner]
//int P[9][9]={{0,0,0,1,0,0,3,0,0},{0,7,0,0,6,0,0,8,0},{6,0,5,8,0,0,9,0,0},{0,0,0,0,0,0,1,0,6},{0,3,0,0,8,0,0,9,0},{9,0,1,0,0,0,0,0,0},{0,0,2,0,0,7,5,0,9},{0,9,0,0,4,0,0,3,0},{0,0,3,0,0,6,0,0,0}};

// ???? SOLVED 8 [noFourthCorner] 7 [emptyRectangle] 5
//int P[9][9]={{6,0,0,8,7,5,0,9,0},{0,2,5,0,0,4,0,0,0},{9,0,0,0,0,0,0,0,0},{0,0,0,9,4,0,0,6,0},{0,1,9,0,0,0,3,7,0},{0,8,0,0,1,7,0,0,0},{0,0,0,0,0,0,0,0,6},{0,0,0,7,0,0,5,2,0},{0,7,0,2,8,6,0,0,4}};

// ***** SOLVED 5
//int P[9][9]={{0,0,0,0,0,0,9,0,2},{0,0,4,8,0,0,0,7,0},{0,2,0,0,1,7,0,0,3},{0,0,0,0,6,0,8,0,0},{2,0,0,3,0,9,0,0,6},{0,0,9,0,4,0,0,0,0},{6,0,0,4,7,0,0,9,0},{0,8,0,0,0,1,3,0,0},{1,0,2,0,0,0,0,0,0}};

// Same as above, but further along - SOLVED 5 [noFourthCorner] 4
//int P[9][9]={{0,0,0,0,0,4,9,0,2},{0,0,4,8,0,0,0,7,0},{0,2,0,0,1,7,0,0,3},{0,0,0,0,6,0,8,0,9},{2,0,0,3,0,9,0,0,6},{0,6,9,0,4,0,0,0,0},{6,0,0,4,7,8,0,9,0},{0,8,7,2,0,1,3,0,0},{1,0,2,0,0,0,0,0,0}};

// ***** SOLVED 8 [noFourthCorner] 7
//int P[9][9]={{0,0,0,0,9,0,0,1,0},{0,5,0,0,0,0,3,0,7},{7,2,0,0,0,0,9,6,0},{0,0,5,6,0,0,0,0,0},{4,0,0,5,0,3,0,0,9},{0,0,0,0,0,7,5,0,0},{0,4,1,0,0,0,0,8,2},{6,0,3,0,0,0,0,5,0},{0,8,0,0,1,0,0,0,0}};

// Same as above, but further along - SOLVED 6 [noFourthCorner] 6
//int P[9][9]={{3,6,0,7,9,0,0,1,5},{1,5,9,0,0,0,3,0,7},{7,2,0,0,0,0,9,6,0},{0,0,5,6,0,0,0,0,0},{4,0,6,5,0,3,0,0,9},{0,0,2,0,0,7,5,0,6},{5,4,1,0,0,0,7,8,2},{6,9,3,0,7,0,0,5,0},{2,8,7,4,1,5,6,9,3}};

// ***** SOLVED (tester) 8
//int P[9][9]={{0,4,0,2,9,1,0,0,0},{5,0,0,0,0,3,0,0,0},{2,8,0,0,0,0,0,0,0},{0,2,0,0,4,0,1,0,0},{6,0,0,0,5,0,0,0,7},{0,0,9,0,3,0,0,8,0},{0,0,0,0,0,0,0,9,5},{0,0,0,5,0,0,0,0,3},{0,0,0,3,1,7,0,6,0}};

// **** SOLVED 4 [noFourthCorner] 4
//int P[9][9]={{0,0,4,0,0,6,0,0,2},{0,0,9,0,0,0,0,0,0},{3,1,0,0,9,7,0,8,0},{0,4,7,0,0,9,0,0,0},{0,5,0,1,0,3,0,6,0},{0,0,0,7,0,0,1,4,0},{0,6,0,5,1,0,0,9,7},{0,0,0,0,0,0,2,0,0},{2,0,0,9,0,0,8,0,0}};

// **** SOLVED 6 [noFourthCorner] 4
//int P[9][9]={{0,0,0,0,0,0,0,0,0},{0,7,0,8,9,2,0,1,0},{9,0,0,0,7,0,0,0,5},{0,0,2,7,0,3,5,0,0},{0,0,0,0,0,0,0,0,0},{0,0,4,6,0,8,3,0,0},{3,0,0,0,6,0,0,0,4},{0,6,0,2,1,9,0,7,0},{0,0,0,0,0,0,0,0,0}};

// *** SOLVED 7 [noFourthCorner] 5
//int P[9][9]={{0,0,2,1,8,5,9,0,0},{0,6,0,0,0,0,0,3,0},{5,0,0,0,0,0,0,0,0},{4,0,0,0,0,0,0,0,0},{2,0,0,0,4,7,5,1,3},{1,0,0,0,0,0,0,0,8},{6,0,0,0,0,0,0,0,7},{0,9,0,0,0,0,0,5,0},{0,0,3,9,1,2,8,0,0}};

// **** SOLVED 7
//int P[9][9]={{0,0,0,0,7,0,3,0,0},{0,0,2,0,0,0,8,7,0},{0,7,0,0,0,9,0,5,4},{0,0,0,0,1,0,9,0,0},{8,0,0,0,0,0,0,0,6},{0,0,7,0,3,0,0,0,0},{9,1,0,2,0,0,0,3,0},{0,3,6,0,0,0,2,0,0},{0,0,8,0,4,0,0,0,0}};

// *** SOLVED 6 [noFourthCorner] 5
//int P[9][9]={{0,0,2,0,0,1,9,0,0},{0,4,3,0,0,0,5,8,0},{9,0,0,0,0,7,0,0,3},{2,0,5,0,0,0,0,0,0},{0,0,0,6,0,5,0,0,0},{0,0,0,0,0,0,1,0,9},{5,0,0,3,0,0,0,0,1},{0,7,4,0,0,0,6,9,0},{0,0,8,9,0,0,4,0,0}};

// *** SOLVED 5
//int P[9][9]={{5,0,2,0,0,0,9,0,0},{0,8,0,5,0,4,0,6,0},{0,0,1,0,0,0,7,0,0},{0,6,0,7,0,9,0,8,4},{0,0,0,0,6,0,0,0,0},{0,9,4,2,5,8,6,3,0},{0,0,7,0,0,0,4,0,0},{0,0,3,0,0,0,2,0,0},{0,0,0,9,2,3,0,0,0}};

// *** SOLVED 4
//int P[9][9]={{0,0,0,3,0,2,1,7,0},{0,9,0,0,6,0,0,0,3},{3,0,8,0,0,0,0,0,0},{4,0,6,0,0,0,0,0,0},{5,8,0,0,0,0,0,3,9},{0,0,0,0,0,0,6,0,1},{0,0,0,0,0,0,3,0,2},{9,0,0,0,7,0,0,5,0},{0,1,4,5,0,8,0,0,0}};

// ** SOLVED 5 [noFourthCorner] 4
//int P[9][9]={{0,4,0,0,0,0,0,5,0},{5,0,0,2,0,7,0,0,6},{0,0,9,0,0,0,2,0,0},{0,5,0,0,3,0,0,9,0},{4,0,7,0,0,0,5,0,8},{0,6,0,0,4,0,0,7,0},{0,0,5,0,0,0,4,0,0},{2,0,0,3,0,8,0,0,7},{0,7,0,0,0,0,0,1,0}};

// ** SOLVED 4
//int P[9][9]={{0,0,0,0,0,4,0,0,0},{0,0,6,0,1,0,7,0,0},{0,4,0,5,0,6,0,8,0},{0,0,9,0,0,3,6,0,5},{0,3,0,0,8,0,0,2,0},{2,0,7,9,0,0,3,0,0},{0,7,0,3,0,9,0,4,0},{0,0,5,0,7,0,9,0,0},{0,0,0,8,0,0,0,0,0}};

// **** SOLVED 6
//int P[9][9]={{0,1,0,0,0,0,0,3,0},{5,0,0,8,0,1,0,0,0},{0,4,0,3,0,0,7,0,0},{0,5,0,0,0,0,0,0,9},{0,0,0,2,7,4,0,0,0},{3,0,0,0,0,0,0,6,0},{0,0,6,0,0,9,0,5,0},{0,0,0,6,0,7,0,0,8},{0,3,0,0,0,0,0,1,0}};

// **** SOLVED 9 [noFourthCorner] 6
//int P[9][9]={{0,0,0,9,4,8,0,0,0},{0,9,0,0,0,0,0,5,0},{0,0,7,0,1,0,3,0,0},{7,0,0,0,0,0,0,0,2},{0,4,9,0,0,0,1,7,0},{3,0,0,0,0,0,0,0,6},{0,0,1,0,9,0,2,0,0},{0,6,0,0,0,0,0,3,0},{0,0,0,5,8,2,0,0,0}};

// **** SOLVED 7 [noFourthCorner] 6
//int P[9][9]={{1,6,0,0,0,9,0,0,0},{3,0,7,0,0,0,0,0,0},{0,0,0,5,0,0,0,2,0},{0,0,0,0,8,0,0,6,3},{6,0,0,0,0,0,0,0,1},{9,5,8,0,3,0,0,0,0},{0,9,0,0,0,7,0,0,0},{4,0,0,0,0,0,2,0,7},{0,0,0,3,0,0,0,9,8}};

// **** SOLVED 6 [noFourthCorner] 5
//int P[9][9]={{1,6,0,0,0,9,0,0,0},{3,0,7,0,0,0,0,0,9},{0,0,0,5,0,0,0,2,0},{0,0,0,0,8,0,9,6,3},{6,0,0,0,0,0,0,0,1},{9,5,8,0,3,0,0,0,0},{0,9,0,0,0,7,0,0,0},{4,0,0,0,0,0,2,0,7},{0,0,0,3,0,0,0,9,8}};

// **** SOLVED 6
//int P[9][9]={ {0,0,4,0,0,0,5,0,0},{3,5,0,0,0,0,0,2,1},{0,0,0,2,0,9,0,0,0},{6,0,0,0,0,0,0,0,3},{0,0,0,3,6,1,0,0,0},{5,0,0,0,0,0,0,0,8},{0,0,0,6,0,8,0,0,0},{2,4,0,0,0,0,0,3,7},{0,0,8,0,0,0,4,0,0}};

// ** SOLVED 4
//int P[9][9]={{0,0,0,0,9,0,0,7,0},{0,0,4,0,0,0,3,0,1},{0,2,0,7,5,0,0,8,0},{0,0,9,0,0,5,0,0,0},{1,0,5,0,0,0,8,0,3},{0,0,0,2,0,0,9,0,0},{0,4,0,0,8,3,0,9,0},{8,0,6,0,0,0,4,0,0},{0,9,0,0,1,0,0,0,0}};

// ** SOLVED 4
//int P[9][9]={{0,0,4,0,0,1,0,0,0},{0,0,6,9,3,0,5,0,0},{8,7,0,0,0,6,0,4,0},{0,5,0,0,0,0,6,0,2},{0,3,0,0,0,0,0,9,0},{4,0,2,0,0,0,0,1,0},{0,4,0,1,0,0,0,7,6},{0,0,9,0,8,2,3,0,0},{0,0,0,4,0,0,8,0,0}};

// SOLVED 5 [noFourthCorner] 5
//int P[9][9]={{0,0,9,8,0,0,0,7,3},{0,8,0,0,0,0,2,0,0},{1,0,0,0,0,7,0,0,0},{4,0,0,0,0,3,0,0,0},{6,0,0,0,0,4,0,0,0},{9,3,5,0,0,2,8,1,0},{3,0,0,9,0,8,0,0,7},{5,0,0,7,0,1,0,0,8},{0,1,7,0,0,0,3,4,0}};

// ** SOLVED 4
//int P[9][9]={{2,8,0,0,0,0,0,4,1},{0,0,0,0,2,0,0,0,0},{6,9,0,8,4,3,0,7,5},{1,0,0,7,0,5,0,0,2},{0,0,4,0,0,0,9,0,0},{8,0,0,4,0,2,0,0,6},{3,5,0,1,8,6,0,9,4},{0,0,0,0,5,0,0,0,0},{9,6,0,0,0,0,0,1,3}};

// * SOLVED 2
//int P[9][9]={{3,0,0,0,6,5,0,0,8},{0,0,0,2,0,3,4,0,0},{0,4,7,0,0,0,5,0,0},{1,9,0,7,0,2,0,4,0},{5,0,0,0,0,0,0,0,2},{0,7,0,9,0,6,0,3,5},{0,0,8,0,0,0,6,2,0},{0,0,1,6,0,9,0,0,0},{6,0,0,1,3,0,0,0,7}};

// * SOLVED 3
//int P[9][9]={{0,6,0,5,4,0,7,9,0},{8,0,0,0,0,6,0,0,3},{9,0,2,7,0,0,5,0,0},{0,8,0,0,0,0,4,0,9},{5,0,0,0,7,0,0,0,2},{2,0,6,0,0,0,0,8,0},{0,0,9,0,0,4,3,0,1},{4,0,0,6,0,0,0,0,5},{0,5,1,0,2,9,0,7,0}};

// ** SOLVED 4
//int P[9][9]={{0,8,0,2,0,9,0,5,0},{5,0,0,0,0,0,0,0,4},{0,0,9,7,0,0,3,0,0},{1,0,0,0,7,0,4,0,5},{0,0,0,0,0,0,0,0,0},{8,0,6,0,3,0,0,0,9},{0,0,4,0,0,6,1,0,0},{3,0,0,0,0,0,0,0,6},{0,6,0,5,0,1,0,8,0}};

// ** SOLVED 6 [noFourthCorner]
//int P[9][9]={{0,0,7,3,0,0,0,9,5},{0,0,0,0,0,5,6,0,1},{2,0,0,0,0,0,0,4,0},{6,0,0,0,5,0,0,7,0},{0,0,0,4,0,1,0,0,0},{0,4,0,0,2,0,0,0,3},{0,9,0,0,0,0,0,0,7},{4,0,8,6,0,0,0,0,0},{7,3,0,0,0,4,9,0,0}};

// Unknown SOLVED 12 [noFourthCorner] 6
//int P[9][9]={{0,0,6,0,9,0,0,4,2},{0,0,3,7,0,0,1,0,0},{1,0,2,0,4,0,6,0,0},{0,0,0,8,0,0,0,0,7},{2,0,0,0,0,0,0,0,3},{3,0,0,0,0,5,0,0,0},{0,0,4,0,1,0,8,0,6},{0,0,8,0,0,9,7,0,0},{9,2,0,0,8,0,5,0,0}};

// **** SOLVED 7 [noFourthCorner] 6
//int P[9][9]={{9,0,0,0,0,7,0,0,6},{0,0,1,0,3,0,0,9,0},{0,0,6,0,0,0,7,0,0},{0,0,0,0,0,0,0,0,5},{0,8,0,3,7,9,0,1,0},{7,0,0,0,0,0,0,0,0},{0,0,5,0,0,0,4,0,0},{0,1,0,0,2,0,3,0,0},{4,0,0,1,0,0,0,0,8}};

// * SOLVED 3
//int P[9][9]={{0,4,0,1,0,8,0,9,0},{8,2,0,0,9,0,0,4,6},{0,0,6,0,0,0,1,0,0},{7,0,0,9,0,4,0,0,1},{0,8,0,0,5,0,0,3,0},{3,0,0,6,0,2,0,0,5},{0,0,7,0,0,0,5,0,0},{4,6,0,0,7,0,0,1,3},{0,3,0,8,0,9,0,2,0}};

// *** SOLVED 5 35% -> 100%
//int P[9][9]={{0,8,1,3,9,5,7,2,0},{0,3,0,0,0,0,0,4,0},{0,0,0,0,0,0,1,0,0},{0,0,0,0,0,1,0,0,0},{0,0,9,2,8,6,5,0,0},{0,0,0,9,0,0,0,0,0},{0,0,5,0,0,0,0,0,0},{0,9,0,0,0,0,0,1,0},{0,7,2,8,5,4,6,3,0}};


// ------------
// *** SOLVED 4 36% -> 100%
//int P[9][9]={{0,0,9,7,6,0,0,0,0},{0,5,0,0,0,3,0,0,0},{7,0,2,0,0,0,1,0,0},{6,0,8,0,0,0,5,0,0},{2,0,0,8,0,0,7,0,0},{0,9,0,0,0,1,4,0,0},{0,0,6,3,2,4,8,7,0},{0,0,0,0,0,0,6,9,2},{0,0,0,0,0,0,0,4,1}};

// Unknown - SOLVED 7 37% -> 100%
//int P[9][9]={{2,0,0,3,0,0,8,6,0},{6,0,0,0,0,0,3,0,0},{0,0,3,0,7,5,0,1,0},{0,0,5,0,8,9,0,3,0},{8,0,0,0,0,0,0,0,2},{0,2,0,7,1,0,5,0,0},{0,3,0,1,5,0,4,0,0},{0,0,6,0,0,0,0,0,1},{0,1,8,0,0,7,0,0,3}};

// **** SOLVED 5 33% -> 100%
//int P[9][9]={{0,0,3,0,0,1,0,0,5},{0,0,7,0,0,5,0,0,2},{4,0,0,7,0,0,3,0,0},{0,0,2,0,0,8,0,0,6},{0,0,4,0,0,0,0,0,3},{3,0,0,1,0,0,2,0,0},{0,0,9,0,0,2,0,0,1},{0,0,5,0,0,6,0,0,9},{1,0,0,5,0,0,8,0,0}};

// **** SOLVED 5 32% -> 100%
//int P[9][9]={{0,0,5,7,0,0,6,0,0},{0,1,0,3,0,4,0,9,0},{0,0,0,0,0,0,0,0,0},{0,8,0,9,0,6,0,1,4},{0,0,0,0,7,0,0,0,0},{9,2,0,4,0,8,0,5,0},{0,0,0,0,0,0,0,0,0},{0,9,0,1,0,5,0,7,0},{0,0,6,0,0,3,2,0,0}};

// **** SOLVED 4 32% -> 100%
//int P[9][9]={{0,6,4,0,0,0,9,0,0},{0,0,0,0,5,0,0,0,8},{1,0,2,0,0,0,7,0,5},{0,0,0,7,0,2,0,0,0},{0,4,0,0,8,0,0,1,0},{0,0,0,6,0,3,0,0,0},{2,0,1,0,0,0,6,0,7},{7,0,0,0,2,0,0,0,0},{0,0,6,0,0,0,8,3,0}};

// **** SOLVED 6 32% -> 100%
//int P[9][9]={{0,0,0,2,0,0,0,0,0},{0,0,0,6,4,0,1,3,0},{0,0,3,0,0,0,0,7,0},{4,5,0,0,6,0,0,0,0},{0,2,0,7,9,4,0,8,0},{0,0,0,0,1,0,0,6,4},{0,1,0,0,0,0,5,0,0},{0,4,6,0,3,8,0,0,0},{0,0,0,0,0,9,0,0,0}};

// ** SOLVED 4 35% -> 100%
//int P[9][9]={{0,0,9,6,0,4,8,0,0},{0,2,0,0,0,0,0,7,0},{6,0,0,3,0,1,0,0,2},{0,0,3,0,0,0,5,0,0},{0,9,0,0,1,0,0,8,0},{0,0,7,0,0,0,6,0,0},{3,0,0,9,0,8,0,0,7},{0,4,0,0,0,0,0,3,0},{0,0,6,5,0,2,9,0,0}};

// *** SOLVED 5 31% -> 100%
//int P[9][9]={{0,0,3,4,0,2,0,7,0},{0,0,0,8,0,0,6,0,0},{0,0,4,9,0,0,0,1,0},{0,0,1,0,5,0,0,0,3},{0,0,0,0,0,0,0,0,0},{8,0,0,0,6,0,1,0,0},{0,9,0,0,0,3,2,0,0},{0,0,6,0,0,7,0,0,0},{0,7,0,1,0,4,3,0,0}};

// *** SOLVED 4 40% -> 100%
//int P[9][9]={{4,1,7,2,0,3,9,8,5},{2,0,0,0,0,9,0,0,0},{6,0,0,0,0,7,0,0,0},{3,9,2,0,0,8,1,5,0},{0,0,0,9,0,0,0,0,7},{0,0,0,1,0,0,0,0,8},{0,0,0,3,0,0,0,0,9},{0,0,0,5,0,0,0,0,2},{5,8,3,0,0,2,4,6,0}};

// *** SOLVED 5 28% -> 100%
//int P[9][9]={{0,0,0,0,6,3,0,1,0},{6,0,0,0,7,0,0,4,0},{0,5,0,0,0,0,9,0,0},{0,0,0,9,0,0,0,8,0},{0,0,3,0,0,0,5,0,0},{0,7,0,0,0,8,0,0,0},{0,0,6,0,0,0,0,3,0},{0,1,0,0,5,0,0,0,6},{0,8,0,6,1,0,0,0,0}};

// * SOLVED 3 41% -> 100%
//int P[9][9]={{0,0,0,8,0,2,0,0,0},{3,1,0,0,5,0,0,9,0},{6,0,8,0,4,0,0,2,0},{1,0,0,3,0,5,0,0,9},{0,3,7,0,0,0,1,8,0},{5,0,0,9,0,8,0,0,4},{0,6,0,0,8,0,3,0,2},{0,4,0,0,9,0,0,7,6},{0,0,0,2,0,7,0,0,0}};

// * SOLVED 3
//int P[9][9]={{0,8,0,0,0,0,0,1,0},{9,0,0,2,0,5,0,0,8},{0,0,0,8,9,6,0,0,0},{0,7,4,0,2,0,8,6,0},{0,0,2,3,0,4,5,0,0},{0,3,9,0,5,0,1,4,0},{0,0,0,7,4,2,0,0,0},{3,0,0,1,0,8,0,0,9},{0,1,0,0,0,0,0,2,0}};

// *** SOLVED 5 - 36% -> 100%
//int P[9][9]={{0,7,0,2,0,0,6,0,0},{0,0,0,4,0,7,2,0,1},{5,1,0,0,0,0,0,0,0},{0,5,0,1,0,8,0,9,2},{0,0,0,0,0,0,0,0,0},{8,6,0,5,0,9,0,3,0},{0,0,0,0,0,0,0,2,8},{7,0,5,8,0,6,0,0,0},{0,0,9,0,0,2,0,7,0}};

// ========== 2016 12 08 ==================== //
// Online (Hard) - SOLVED 5 - 36% -> 100%
//int P[9][9]={{0,0,6,2,0,0,5,0,0},{0,0,0,4,0,7,1,0,9},{4,0,7,0,0,0,0,2,0},{0,0,0,0,8,2,0,5,0},{0,0,4,0,0,0,7,0,0},{0,5,0,3,7,0,0,0,0},{0,8,0,0,0,0,6,0,5},{9,0,3,7,0,6,0,0,0},{0,0,5,0,0,9,4,0,0}};

// MY PUZZLE  SOLVED 2 (47%)
//int P[9][9]={{1,3,6,2,9,8,5,4,7},{0,0,0,4,0,0,0,0,9},{0,9,0,5,0,0,3,0,0},{0,7,0,0,0,2,0,0,0},{8,0,0,0,0,0,0,3,0},{2,0,0,3,7,4,0,1,0},{7,0,2,0,0,3,0,0,0},{9,0,0,7,5,0,0,0,0},{0,1,5,0,2,0,0,0,3}};

//int P[9][9]={{0,3,5,2,9,8,1,4,0},{0,0,8,0,0,0,0,0,9},{0,0,0,0,0,1,0,0,8},{0,0,0,6,3,0,5,0,0},{0,0,0,0,0,0,0,0,2},{0,0,0,0,0,0,0,1,0},{7,0,0,1,4,0,6,9,5},{9,0,0,0,0,0,0,8,0},{0,0,0,0,0,0,4,7,3}};

// **** SOLVED 5 (30%)
//int P[9][9]={{0,0,4,9,1,0,0,0,0},{0,5,0,0,0,8,2,0,0},{1,0,0,0,0,0,0,7,0},{7,0,0,0,0,0,0,6,0},{3,0,0,0,4,0,0,0,9},{0,1,0,0,0,0,0,0,8},{0,9,0,0,0,0,0,0,5},{0,0,6,7,0,0,0,4,0},{0,0,0,0,3,9,6,0,0}};


// MY PUZZLE 9 (30%)
//int P[9][9]={{1,0,0,0,9,0,5,0,0},{5,0,0,0,0,0,1,0,0},{0,0,7,0,0,1,0,2,0},{0,0,0,0,8,2,0,0,4},{0,6,0,0,0,0,7,0,0},{0,0,0,3,0,4,8,0,0},{0,8,0,1,0,3,0,0,0},{9,0,0,7,0,0,0,0,1},{0,0,5,0,0,0,4,0,0}};

// MY PUZZLE 6 (35%)
//int P[9][9]={{0,0,3,4,0,0,7,8,9},{0,0,0,0,0,0,0,0,3},{0,8,0,0,2,0,4,0,0},{9,0,2,0,4,0,0,0,0},{0,0,0,0,0,0,0,0,0},{6,7,0,0,0,2,3,0,5},{0,0,1,0,0,0,5,6,0},{0,3,0,0,6,0,0,0,1},{0,0,0,8,9,0,2,0,4}};

// MY PUZZLE 6 (33%)
//int P[9][9]={{5,6,0,0,0,0,0,0,4},{2,0,0,0,0,0,0,9,0},{0,0,1,2,0,0,0,0,0},{0,0,0,7,0,0,0,2,0},{0,0,9,0,0,0,4,0,6},{0,2,0,4,0,6,7,8,0},{0,4,0,6,7,0,9,1,2},{0,1,0,0,0,0,6,0,0},{0,0,8,0,0,2,0,0,0}};

// 3 (35%)
//int P[9][9]={{0,0,0,0,9,1,0,0,0},{2,0,0,0,6,0,0,9,0},{0,0,0,0,0,0,5,0,7},{1,2,3,0,0,0,0,0,0},{0,8,0,0,0,0,4,0,0},{0,0,6,7,8,9,1,0,0},{0,1,2,0,0,0,0,7,8},{0,0,8,0,0,0,3,0,0},{3,4,5,6,0,0,0,0,0}};

// 5 (35%)
//int P[9][9]={{0,0,6,0,0,0,0,0,3},{0,0,0,4,0,0,0,8,0},{7,0,9,0,2,0,0,0,6},{0,6,0,0,0,0,0,3,4},{8,9,0,2,0,0,0,0,0},{0,3,0,0,0,7,8,0,1},{0,4,5,6,0,0,0,0,2},{0,0,0,0,1,0,0,0,0},{9,0,2,0,0,0,0,7,8}};

// #68 4 (32%)
//int P[9][9]={{0,0,0,0,0,0,0,0,0},{0,0,2,0,0,0,6,7,0},{0,7,0,9,0,0,3,4,5},{0,5,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,9},{0,0,0,0,2,3,4,0,6},{0,0,1,2,0,4,0,0,0},{0,3,0,5,0,7,0,0,1},{5,6,0,0,9,0,0,0,0}};

// #69 4 (35%)
//int P[9][9]={{3,0,0,0,0,6,0,0,1},{6,5,0,0,0,0,2,0,0},{0,0,0,0,4,0,5,0,0},{7,0,0,9,0,1,0,4,5},{0,0,2,0,5,0,0,7,0},{0,3,0,6,0,0,0,1,0},{0,4,0,0,0,0,0,0,3},{0,7,0,0,0,0,0,5,6},{2,1,0,4,6,0,0,0,0}};

// #70 3
//int P[9][9]={{3,1,2,0,0,0,0,6,0},{0,0,0,5,0,0,0,0,0},{6,4,0,0,0,1,0,0,0},{0,0,9,0,7,5,0,0,0},{7,0,6,0,0,0,0,1,9},{0,2,0,0,0,0,5,0,0},{5,0,4,1,2,0,6,0,0},{0,0,7,4,0,0,9,0,0},{0,9,1,7,8,0,0,0,0}};

// #71 4
//int P[9][9]={{5,0,0,8,0,0,0,0,0},{0,1,9,0,0,0,0,0,0},{8,0,0,0,9,0,0,3,4},{0,0,0,0,1,0,0,0,0},{0,0,0,0,0,0,9,7,8},{6,5,0,9,7,0,3,0,0},{0,0,0,1,8,0,0,0,0},{1,0,0,4,0,3,0,0,0},{4,3,2,0,5,6,0,8,0}};

// #72 5
//int P[9][9]={{0,4,3,1,2,0,0,0,0},{0,1,0,0,0,6,0,0,0},{8,0,0,0,0,0,0,0,2},{0,0,0,8,0,7,5,0,0},{6,0,4,0,0,0,8,0,0},{0,0,0,0,6,4,0,1,3},{0,0,0,0,0,0,0,0,4},{0,6,0,0,0,2,9,0,1},{0,0,2,9,1,0,0,5,0}};

// #73 5
//int P[9][9]={{0,0,0,0,0,0,2,0,3},{0,0,0,6,7,5,0,1,9},{0,1,9,0,0,0,0,0,0},{6,0,7,0,2,0,3,0,4},{0,5,4,0,0,6,0,0,0},{0,0,0,0,5,0,0,0,0},{4,0,0,0,0,0,0,0,0},{0,3,2,0,6,0,0,9,0},{7,0,0,0,3,0,4,0,5}};

// #74 4
//int P[9][9]={{0,0,0,0,0,1,0,7,0},{0,0,0,6,8,0,0,4,0},{0,0,0,0,0,0,9,0,2},{0,0,0,0,4,3,8,0,0},{0,0,0,0,0,9,0,6,0},{1,0,8,5,0,0,0,0,0},{0,0,0,7,0,0,0,5,6},{0,0,7,4,0,0,0,2,0},{6,5,0,0,0,0,0,8,9}};

// #75 4
//int P[9][9]={{0,0,0,0,5,4,0,0,0},{0,9,0,6,0,0,5,0,3},{0,0,0,0,2,0,0,7,6},{0,0,9,0,0,0,0,2,1},{0,0,6,1,3,0,0,0,0},{2,0,0,0,0,0,0,5,4},{9,8,0,0,7,6,4,0,0},{0,0,0,8,0,9,7,0,0},{0,5,0,0,0,0,0,0,0}};

// #76 5
//int P[9][9]={{1,0,2,6,0,0,0,3,4},{0,0,0,0,1,0,0,6,0},{7,0,8,0,0,0,2,0,0},{0,5,0,0,3,0,0,0,0},{0,0,4,8,0,0,0,5,6},{0,0,0,5,0,7,4,0,0},{5,0,0,0,0,0,9,0,0},{0,0,3,7,0,0,0,0,0},{8,0,0,0,0,6,0,1,2}};

// #77 3
//int P[9][9]={{0,0,2,0,0,0,0,0,0},{7,0,5,0,1,8,2,3,0},{0,9,0,0,0,0,5,6,7},{0,7,0,0,2,9,0,4,0},{0,0,9,0,5,3,0,7,8},{0,0,0,0,0,0,0,0,0},{9,0,0,2,3,0,0,5,0},{0,2,1,0,0,0,0,0,0},{0,0,4,8,9,0,1,0,0}};

// #78 5
//int P[9][9]={{0,0,0,0,8,0,0,0,5},{5,0,0,0,0,1,0,6,0},{0,0,0,3,0,4,1,0,0},{9,0,0,4,0,5,0,0,0},{0,2,1,7,0,0,0,0,0},{0,0,0,0,3,0,8,0,0},{4,0,2,8,0,9,0,0,7},{7,6,5,0,0,0,0,8,0},{0,0,0,0,0,0,0,2,0}};

// #79 3
//int P[9][9]={{2,1,3,0,6,0,0,9,0},{0,0,0,0,9,0,0,0,0},{0,7,0,1,3,0,4,0,5},{0,0,0,0,4,3,0,0,0},{6,5,7,8,0,0,0,4,0},{0,2,0,0,0,0,0,0,0},{7,0,8,9,0,1,0,0,0},{0,0,0,0,8,0,0,0,1},{1,0,2,3,0,0,6,0,7}};

// #80 4
//int P[9][9]={{3,0,0,0,8,0,0,6,5},{9,8,7,0,0,0,0,0,0},{0,0,4,1,0,0,0,0,0},{0,1,0,0,0,0,0,5,4},{0,0,6,0,0,0,9,2,0},{5,4,3,0,0,2,0,8,0},{0,6,0,0,3,0,8,0,0},{4,0,0,0,9,1,0,0,0},{0,0,8,0,0,7,2,0,0}};

// #81 4
//int P[9][9]={{8,0,7,1,0,0,3,0,0},{0,9,0,0,3,0,0,0,0},{5,3,4,0,0,0,9,0,2},{0,0,0,5,4,0,0,0,9},{9,0,0,2,1,3,0,5,0},{0,4,5,0,0,0,0,0,0},{0,0,0,6,5,7,0,0,1},{0,0,0,0,0,0,2,0,4},{0,0,0,3,0,0,5,6,0}};

// #82 4
//int P[9][9]={{0,4,3,0,0,5,0,0,0},{0,0,0,0,0,0,6,7,0},{0,0,0,0,1,0,0,0,2},{0,0,7,1,2,9,0,0,0},{0,5,0,0,0,0,0,0,9},{0,0,0,4,0,3,0,0,0},{1,3,2,0,6,0,0,0,0},{0,0,8,0,0,1,5,0,4},{0,6,0,0,0,0,0,3,0}};

// #83 4
//int P[9][9]={{0,0,0,0,0,7,0,8,9},{0,6,0,0,8,0,0,0,0},{1,0,0,0,2,0,0,0,0},{5,0,0,7,0,0,0,0,0},{0,0,6,1,0,2,5,0,4},{0,1,9,0,3,0,0,0,0},{9,0,0,0,0,0,6,0,0},{0,0,1,5,0,0,0,0,8},{6,0,0,8,7,0,0,0,0}};

// #84 5
//int P[9][9]={{0,0,0,0,0,8,9,0,0},{0,0,1,0,0,0,0,0,7},{0,0,0,9,1,0,3,5,4},{4,6,5,0,8,0,1,0,0},{1,3,0,0,0,6,0,0,0},{0,0,0,0,2,0,0,0,5},{2,0,3,0,6,0,0,0,0},{0,7,0,8,0,0,0,4,3},{0,0,0,0,0,0,0,7,0}};

// #85 4
//int P[9][9]={{0,0,1,0,0,0,7,0,9},{0,0,0,8,7,0,0,2,3},{0,9,0,0,0,3,0,5,0},{3,0,0,0,0,7,8,0,0},{0,0,0,0,2,4,0,0,7},{0,0,0,9,0,1,0,0,0},{0,0,0,7,6,8,9,0,0},{0,2,0,4,0,0,0,0,0},{7,0,0,0,9,0,0,0,0}};

// #86 7
//int P[9][9]={{0,0,0,0,3,4,0,1,0},{0,0,0,0,0,1,8,0,6},{0,0,0,8,0,7,5,0,0},{0,0,4,0,0,0,0,6,5},{6,0,0,4,0,3,0,0,0},{9,8,0,7,0,0,0,0,0},{0,0,0,0,0,5,0,0,0},{2,1,3,0,0,0,0,0,0},{0,4,0,0,1,0,9,0,0}};

// #87 5
//int P[9][9]={{9,1,0,7,6,0,0,0,0},{0,4,5,0,0,0,0,6,8},{0,0,8,0,0,0,0,9,0},{0,0,6,0,0,3,0,7,9},{0,8,0,0,0,0,0,0,0},{0,0,3,0,7,0,5,4,0},{0,0,0,0,0,0,3,0,0},{0,0,4,9,8,0,0,0,0},{5,0,7,0,0,4,0,0,0}};

// #88 4
//int P[9][9]={{0,0,0,2,1,0,0,0,0},{0,1,9,0,4,3,0,0,0},{5,4,0,0,0,0,0,9,0},{0,2,0,6,0,0,8,7,0},{0,0,0,0,2,0,5,0,0},{0,0,4,0,0,0,0,0,3},{0,0,0,0,3,0,0,0,7},{0,6,0,1,0,8,0,2,4},{0,0,0,0,6,0,0,8,0}};

// #?? 5
//int P[9][9]={{0,0,0,0,0,6,0,9,0},{0,8,0,0,4,0,0,0,7},{0,4,0,1,0,0,0,0,0},{8,0,0,0,7,0,6,5,0},{0,6,0,0,0,2,0,0,0},{0,0,0,5,0,1,0,0,2},{0,1,0,0,0,5,0,0,0},{6,0,5,0,0,0,0,7,0},{0,0,0,0,0,4,2,6,0}};

// #?? 6
//int P[9][9]={{8,0,0,0,0,0,0,0,4},{3,0,0,0,1,0,0,0,0},{0,7,2,0,0,3,0,1,0},{0,0,0,5,4,0,0,0,0},{0,3,0,0,0,2,6,0,0},{0,5,0,3,0,0,2,7,0},{0,0,0,1,8,0,4,0,0},{0,0,8,0,0,0,0,0,0},{4,2,5,0,0,0,7,0,1}};


// Level 5
//int P[9][9]={{7,1,0,0,0,0,0,0,0},{0,0,5,9,0,0,0,0,6},{0,0,0,0,0,0,4,0,5},{0,0,0,0,1,0,5,0,0},{0,4,0,0,8,0,0,0,9},{0,2,0,0,0,3,0,4,0},{0,0,4,3,0,0,9,0,0},{9,6,0,5,0,0,0,0,2},{8,0,2,6,0,0,0,0,0}};

// Unknown - 6
//int P[9][9]={{3,2,5,4,0,0,0,0,0},{0,0,8,5,0,0,7,0,0},{0,0,0,0,2,0,0,0,4},{0,3,0,2,0,0,0,0,5},{0,0,7,3,0,1,9,0,0},{6,0,0,0,0,9,0,3,0},{8,0,0,0,1,0,0,0,0},{0,0,3,0,0,5,2,0,0},{0,0,0,0,0,3,1,6,8}};

// SEN - 12/10 - 5
//int P[9][9]={{0,5,0,0,0,0,0,0,0},{4,3,0,0,1,0,7,0,0},{0,0,0,8,0,2,0,1,0},{0,0,2,0,0,0,9,0,0},{0,7,0,0,3,0,0,5,0},{0,0,3,0,0,0,1,0,0},{0,8,0,4,0,9,0,0,0},{0,0,5,0,8,0,0,3,2},{0,0,0,0,0,0,0,6,0}};

// SEN - 12/12 - 2
//int P[9][9]={{0,8,0,9,7,1,0,6,0},{3,0,5,0,0,0,2,0,9},{0,7,0,0,0,0,0,1,0},{1,0,0,7,0,8,0,0,5},{6,0,0,0,1,0,0,0,8},{2,0,0,3,0,9,0,0,1},{0,2,0,0,0,0,0,5,0},{5,0,3,0,0,0,1,0,7},{0,4,0,5,9,6,0,8,0}};

// #89 - 6
//int P[9][9]={{0,0,0,0,7,0,0,2,6},{4,5,0,2,0,0,3,0,0},{0,0,0,0,0,0,0,0,0},{8,0,0,4,5,0,0,0,0},{7,4,0,0,0,0,0,0,0},{0,2,0,8,0,0,0,5,7},{0,0,1,0,0,0,0,6,0},{2,0,9,0,0,1,0,0,5},{0,0,0,6,0,9,0,8,0}};

//int P[9][9]={{6,7,4,3,1,2,8,9,5},{8,1,2,4,5,9,7,3,6},{3,9,5,8,7,6,4,2,1},{7,6,9,5,8,3,1,4,2},{5,8,3,2,4,1,6,7,9},{4,2,1,9,6,7,5,8,3},{9,4,8,1,2,5,3,6,7},{2,5,7,6,3,8,9,1,4},{1,3,6,7,9,4,2,5,8}};

//int P[9][9]={{3,5,7,6,4,8,1,9,2},{6,2,4,9,7,1,5,3,8},{9,1,8,2,3,5,6,7,4},{2,4,3,7,1,6,8,5,9},{8,7,1,4,5,9,2,6,3},{5,6,9,8,2,3,4,1,7},{4,3,6,5,8,7,9,2,1},{1,9,2,3,6,4,7,8,5},{7,8,5,1,9,2,3,4,6}};

//int P[9][9]={{7,3,6,8,5,1,9,4,2},{4,5,2,9,6,7,1,3,8},{1,9,8,4,2,3,7,6,5},{9,7,3,5,1,4,8,2,6},{2,6,4,7,9,8,3,5,1},{8,1,5,2,3,6,4,9,7},{5,4,1,3,7,2,6,8,9},{3,2,7,6,8,9,5,1,4},{6,8,9,1,4,5,2,7,3}};

//int P[9][9]={{3,5,7,6,4,8,1,9,2},{6,2,4,9,7,1,5,3,8},{9,1,8,2,3,5,6,7,4},{2,4,3,7,1,6,8,5,9},{8,7,1,4,5,9,2,6,3},{5,6,9,8,2,3,4,1,7},{4,3,6,5,8,7,9,2,1},{1,9,2,3,6,4,7,8,5},{7,8,5,1,9,2,3,4,6}};

//int P[9][9];
//int P[9][9]={{3,0,1,0,0,0,7,0,8},{7,0,9,0,0,0,6,0,3},{6,5,8,2,3,7,4,1,9},{4,8,6,0,0,0,0,9,7},{2,9,3,4,7,6,5,8,1},{5,1,7,0,0,0,0,4,6},{9,7,5,3,8,4,1,6,2},{1,0,2,0,0,0,8,0,4},{8,0,4,0,0,0,9,0,5}};

// fwd declaration
void printPuzzle(int which);
void printArray()
{
  cout << "int P[9][9]={";
  
  for( int row=0; row<9; row++ )
    {
      cout << "{";
      for( int col=0; col<9; col++ )
	{
	  cout << puzzle[row][col].getValue();
	  if(col<8) cout << ",";
	}
      cout << "}";
      if(row<8) cout << ",";
    }
  cout << "};" << endl;

}
void printRaw()
{
  for( int row=0; row<9; row++ )
    {
      for( int col=0; col<9; col++ )
	{
	  cout << puzzle[row][col].getValue() << ",";
	}
      cout << endl;
    }
}

int verifyWin()
{
  int checksum;
  int validity=1;
  // check columns first
  for( int r=0;r<9;r++ )
    {
      checksum=0;

      for( int c=0; c<9; c++ )
	{
	  checksum+=puzzle[r][c].getValue();
	}
      if( checksum != 45 ) validity=0;
    }
  // then check rows
  for( int c=0; c<9; c++ )
    {
      checksum=0;
      for( int r=0; r<9; r++ )
	{
	  checksum+=puzzle[r][c].getValue();
	}
      if( checksum != 45 ) validity=0;

    }
  return validity;

}
int cell::isPair()
{
  if( howManyCouldBes() == 2 ) return(1);
  return(0);
}
void cell::xwingRedux()
{

  // check a row for a couldBe() that only appears twice
  // find another row with that same columns
  // remove that couldBe() from the remaining columns

  if( howManyCouldBes() != 2 ) return; // if this cell is NOT a pair return
  int v0[2];
  int v1[2];
  int v2[2];
  
  int r[2];
  int c[2];
  
  v0[0]=minCouldBe();
  v0[1]=maxCouldBe();
  v1[0]=-1;
  v1[1]=-1;
  v2[0]=-1;
  v2[1]=-1;
 
  // look in my row for a matching pair
  for(int i=0; i<9; i++)
    {
      if( i==mycol )
	{
	  // skip it
	}
      else if( puzzle[myrow][i].howManyCouldBes() == 2 )
	{
	  if( (puzzle[myrow][i].minCouldBe() == v0[0] ) && (puzzle[myrow][i].maxCouldBe()==v0[1] ))
	    {
	      v1[0]=puzzle[myrow][i].minCouldBe();
	      v1[1]=puzzle[myrow][i].maxCouldBe();
	      c[0]=i;
	      r[0]=myrow;
	      i=10;
	    }
	}
    }
  if( v1[0]==-1 ) return;

  // look in my column for a semi-matching pair
  for(int i=0; i<9; i++)
    {
      if( i==myrow )
	{
	  // skip it
	}
      else if( puzzle[i][mycol].howManyCouldBes() == 2 )
	{
	  if( (puzzle[i][mycol].minCouldBe() == v1[0] ) || (puzzle[i][mycol].maxCouldBe()==v1[1] ))
	    {
	      v2[0]=puzzle[i][mycol].minCouldBe();
	      v2[1]=puzzle[i][mycol].maxCouldBe();
	      c[1]=mycol;
	      r[1]=i;
	      i=10;
	    }
	}
    }
  if( v2[0]==-1 ) return;


  
  
  return;
}
void cell::noFourthCorner()
{
  // if this cell is a pair
  // and if there's a matching pair to the north or south
  // and to the east or west then remove that pair from
  // the fourth corner
  if( howManyCouldBes() != 2 ) return;
  int v0[2];
  int v1[2];
  int v2[2];

  int r[2];
  int c[2];
  
  v0[0]=minCouldBe();
  v0[1]=maxCouldBe();
  v1[0]=-1;
  v1[1]=-1;
  v2[0]=-1;
  v2[1]=-1;
  // look in my row for a matching pair
  for(int i=0; i<9; i++)
    {
      if( i==mycol )
	{
	  // skip it
	}
      else if( puzzle[myrow][i].howManyCouldBes() == 2 )
	{
	  if( (puzzle[myrow][i].minCouldBe() == v0[0] ) && (puzzle[myrow][i].maxCouldBe()==v0[1] ))
	    {
	      v1[0]=puzzle[myrow][i].minCouldBe();
	      v1[1]=puzzle[myrow][i].maxCouldBe();
	      c[0]=i;
	      r[0]=myrow;
	      i=10;
	    }
	}
    }
  if( v1[0]==-1 ) return;

  // look in my column for a matching pair
for(int i=0; i<9; i++)
    {
      if( i==myrow )
	{
	  // skip it
	}
      else if( puzzle[i][mycol].isPair()==1 )
	{
	  if( (puzzle[i][mycol].minCouldBe() == v0[0] ) && (puzzle[i][mycol].maxCouldBe()==v0[1] ))
	    {
	      v2[0]=puzzle[i][mycol].minCouldBe();
	      v2[1]=puzzle[i][mycol].maxCouldBe();
	      c[1]=mycol;
	      r[1]=i;
	      i=10;
	    }
	}
    }
  if( v2[0]==-1 ) return;

  if( puzzle[r[1]][c[0]].couldIBe(v1[0])== 1 )
    {
      if((DEBUG==1)||(DEBUG==2))cout << "[noFourthCorner] ("<< r[1] << "," << c[0] << ") can't be " << v1[0] << endl; 
      puzzle[r[1]][c[0]].cantBe(v1[0]);
    }
  if( puzzle[r[1]][c[0]].couldIBe(v1[1])== 1 )
    {
      if((DEBUG==1)||(DEBUG==2))cout << "[noFourthCorner] ("<< r[1] << "," << c[0] << ") can't be " << v1[1] << endl; 
      puzzle[r[1]][c[0]].cantBe(v1[1]);
    }
  return;
  
}

void cell::boxLineRedux()
{
  int count=0;
  for( int v=1; v<10; v++ )
    {
      count=0;
      // first check column
      for( int r=0; r<9; r++ )
	{
	  
	  if( puzzle[r][mycol].getGroup() == getGroup() )
	    {
	      //skip
	    }
	  else
	    {
	      if( puzzle[r][mycol].couldIBe(v) == 1 )
		{
		  count++;
		}
	    }
	  
	}
      
      if( count==0 )
	{
	  // remove that couldBe from my group
	  for( int r1=startrow; r1<(startrow+3); r1++ )
	    {
	      for( int c1=startcol; c1<(startcol+3); c1++ )
		{
		  if( c1!=mycol )
		    {
		      if(puzzle[r1][c1].couldIBe(v) == 1 )
			{
			  if((DEBUG==1)||(DEBUG==2)) cout << "[boxLineRedux] (col) cell (" << r1 << "," << c1 << ") can't be a " << v << endl;
			  puzzle[r1][c1].cantBe(v);
			}
		    }

		}
	      
	    }

	}

    }
  // Now same for ROWS
    for( int v=1; v<10; v++ )
    {
      count=0;
      // first check row
      for( int c=0; c<9; c++ )
	{
	  
	  if( puzzle[myrow][c].getGroup() == getGroup() )
	    {
	      //skip
	    }
	  else
	    {
	      if( puzzle[myrow][c].couldIBe(v) == 1 )
		{
		  count++;
		}
	    }
	  
	}
      
      if( count==0 )
	{
	  // remove that couldBe from my group
	  for( int r1=startrow; r1<(startrow+3); r1++ )
	    {
	      for( int c1=startcol; c1<(startcol+3); c1++ )
		{
		  if( r1!=myrow )
		    {
		      if(puzzle[r1][c1].couldIBe(v) == 1 )
			{
			  if((DEBUG==1)||(DEBUG==2)) cout << "[boxLineRedux] (row) cell (" << r1 << "," << c1 << ") can't be a " << v << endl;
			  puzzle[r1][c1].cantBe(v);
			}
		    }

		}
	      
	    }

	}

    }



}
void cell::emptyRectangle()
{
  //first make sure that this cell is the intersection cell
  //then look for a pair in row and in column with one of the same couldbes
  //remove that could be from the opposite corner of the rectangle
  if(DEBUG==3) cout << endl << "[emptyRectangle] checking (" << myrow << "," << mycol << ")" << endl;
  int isIntersection=0;
  int foundFirstPair=0;
  int foundSecondPair=0;
  
  int count;
  int v2[2];  v2[0]=v2[1]=-1;
  // v is the value we're checking for
  for( int v=1; v<10; v++ )
    {
      // if there's already  "v" in my row and column, don't worry about it
      int noNeed=0;
      for( int s=0; s<9; s++ )
	{
	  if( puzzle[s][mycol].getValue() == v )
	    {
	      if(DEBUG==3) cout << "[emptyRectangle] " << puzzle[s][mycol].getValue() << " = " << v << endl;
	      noNeed++;
	    }
	}
      for( int s=0; s<9; s++ )
	{
	  if( puzzle[myrow][s].getValue() == v )
	    {
	      if(DEBUG==3) cout << "[emptyRectangle] " << puzzle[myrow][s].getValue() << " = " << v << endl;
	      noNeed++;
	    }
	}
      
      //if( getValue() == v ) noNeed=2;
      
      if( noNeed == 2)
	{
	  if(DEBUG==3) cout << "[emptyRectangle] there's already a " << v << " in row+col" << endl << endl;
	}
      else
	{
	  isIntersection=0;
	  foundFirstPair=0;
	  foundSecondPair=0;
	  count=0;
	  for( int r=startrow; r<(startrow+3); r++ )
	    {
	      for( int c=startcol; c<(startcol+3); c++ )
		{
		  if( r==myrow )
		    {
		      // skip
		    }
		  else if( c==mycol )
		    {
		      // skip
		    }
		  else
		    {
		      // make sure that value isn't in any of the other four cells
		      if(puzzle[r][c].couldIBe(v)==0)
			{
			  if(DEBUG==3) cout << "[emptyRectangle] (" << r << "," << c << ") is not a " << v << endl;
			  count++;
			}
		      else
			{
			  if(DEBUG==3) cout << "[emptyRectangle] (" << r << "," << c << ") could be a " << v << endl;
			}
		    }
		}
	    }
	  
	  if( count==4 )
	    {
	      if(DEBUG==3) cout << "[emptyRectangle] so (" << myrow << "," << mycol << ") is an intersection for " << v << endl;
	      isIntersection=1;
	      
	    }
	  else
	    {
	      isIntersection=0;
	      // don't bother following through eliminating v
	      
	    }
	  
	  // now that I know that I'm an intersection
	  // check this column for a pair that has v
	  if( isIntersection == 1)
	    {
	      for( int i=0; i<9; i++ )
		{
		  foundFirstPair=0;
		  if( puzzle[i][mycol].getGroup() == getGroup() )
		    {
		      foundFirstPair=0;
		      if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << mycol << ") skipped because it's in the same group" << endl;
		    }
		  else if( puzzle[i][mycol].howManyCouldBes() != 2  )
		    {
		      foundFirstPair=0;
		      if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << mycol << ") is not a pair"  << endl;
		    }
		  else if( (puzzle[i][mycol].maxCouldBe() == v) && (puzzle[i][mycol].isPair()==1) )
		    {
		      // now we have a match
		      v2[0]=puzzle[i][mycol].minCouldBe();
		      v2[1]=puzzle[i][mycol].maxCouldBe();
		      foundFirstPair=1;
		      if(DEBUG==3) cout << "[emptyRectangle] cell: (" << i << "," << mycol << ") has a " << v << endl;
		      // IN HERE LOOK FOR MATCH IN THE ROW!!!
		      if( foundFirstPair==1 )
			{
			  for( int j=0; j<9; j++ )
			    {
			      if( j==mycol )
				{
				  // skip this cell
				  if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << j << ") skipped because it's the cell with the first pair." << endl;
				}
			      else if( puzzle[i][j].howManyCouldBes()!=2 )
				{
				  // skip this one
				  if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << j << ") skipped because it's not a pair [" << puzzle[i][j].howManyCouldBes() << "]" << endl;
				}
			      else if( (puzzle[i][j].minCouldBe()==v2[0])  &&  (puzzle[i][j].maxCouldBe()==v2[1]))
				{
				  foundSecondPair=1;
				  if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << j << ") matches cell (" << i << "," << mycol << ")" << endl;
				  
				  if( puzzle[myrow][j].couldIBe( v )==1 )
				    {
				      if( puzzle[myrow][j].getGroup() != getGroup() )
					{
					  if(DEBUG==3) cout << "*****";
					  if((DEBUG==1)||(DEBUG==2)) cout << "[emptyRectangle] (" << myrow << "," << j << ") can't be " << v << endl;
					  puzzle[myrow][j].cantBe(v);
					}
				      return;
				    }
				}
			      else if( (puzzle[i][j].maxCouldBe()==v2[0])  &&  (puzzle[i][j].minCouldBe()==v2[1] ))
				{
				  if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << j << ") matches cell (" << i << "," << mycol << ")" << endl;
				  if( puzzle[myrow][j].couldIBe( v )==1 )
				    {
				      if( puzzle[myrow][j].getGroup() != getGroup() )
					{
					  if(DEBUG==3) cout << "*****";
					  if((DEBUG==1)||(DEBUG==2)) cout << "[emptyRectangle] (" << myrow << "," << j << ") can't be " << v << endl;
					  puzzle[myrow][j].cantBe(v);
					}
				      return;
				    }
				}
			      else
				{
				  if(DEBUG==3) cout << "[emptyRectangle] fell through the ifs at cell: (" << i << "," << j << ") it's a pair, but doesn't match cell (" << i << "," << mycol << ")" << endl;
				  if(DEBUG==3) cout << "[emptyRectangle] v2[0]: " << v2[0] << " v2[1]: " << v2[1] << " mymin: " << puzzle[i][j].minCouldBe() << " mymax: " << puzzle[i][j].maxCouldBe() << endl;
				}
			    }
			}
		      foundFirstPair=0;
		      
		    }
		  else if( (puzzle[i][mycol].minCouldBe() == v) && (puzzle[i][mycol].isPair()==1) )
		    {
		      // now we have a match
		      v2[0]=puzzle[i][mycol].maxCouldBe();
		      v2[1]=puzzle[i][mycol].minCouldBe();
		      foundFirstPair=1;
		      if(DEBUG==3) cout << "[emptyRectangle] cell: (" << i << "," << mycol << ") has a " << v << endl;
		      // IN HERE LOOK FOR MATCH IN THE ROW!!!
		      if( foundFirstPair==1 )
			{
			  for( int j=0; j<9; j++ )
			    {
			      if( j==mycol )
				{
				  // skip this cell
				  if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << j << ") skipped because it's the cell with the first pair." << endl;
				}
			      else if( puzzle[i][j].howManyCouldBes()!=2 )
				{
				  // skip this one
				  if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << j << ") skipped because it's not a pair [" << puzzle[i][j].howManyCouldBes() << "]" << endl;
				}
			      else if( (puzzle[i][j].minCouldBe()==v2[0])  &&  (puzzle[i][j].maxCouldBe()==v2[1]))
				{
				  foundSecondPair=1;
				  if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << j << ") matches cell (" << i << "," << mycol << ")" << endl;
				  
				  if( puzzle[myrow][j].couldIBe( v )==1 )
				    {
				      if( puzzle[myrow][j].getGroup() != getGroup() )
					{
					  
					  if(DEBUG==3) cout << "*****";
					  if((DEBUG==1)||(DEBUG==2)) cout << "[emptyRectangle] (" << myrow << "," << j << ") can't be " << v << endl;
					  puzzle[myrow][j].cantBe(v);
					}
				      //return;
				    }
				}
			      else if( (puzzle[i][j].maxCouldBe()==v2[0])  &&  (puzzle[i][j].minCouldBe()==v2[1] ))
				{
				  if(DEBUG==3) cout << "[emptyRectangle] cell (" << i << "," << j << ") matches cell (" << i << "," << mycol << ")" << endl;
				  if( puzzle[myrow][j].couldIBe( v )==1 )
				    {
				      if( puzzle[myrow][j].getGroup() != getGroup() )
					{
					  
					  if(DEBUG==3) cout << "*****";
					  if((DEBUG==1)||(DEBUG==2)) cout << "[emptyRectangle] (" << myrow << "," << j << ") can't be " << v << endl;
					  puzzle[myrow][j].cantBe(v);
					}
				      //return;
				    }
				}
			      else
				{
				  if(DEBUG==3) cout << "[emptyRectangle] fell through the ifs at cell: (" << i << "," << j << ") it's a pair, but doesn't match cell (" << i << "," << mycol << ")" << endl;
				  if(DEBUG==3) cout << "[emptyRectangle] v2[0]: " << v2[0] << " v2[1]: " << v2[1] << " mymin: " << puzzle[i][j].minCouldBe() << " mymax: " << puzzle[i][j].maxCouldBe() << endl;
				}
			    }
			}
		      foundFirstPair=0;
		    }
		  else
		    {
		      foundFirstPair=0;
		    }
		}	 
	    }
	}
    }
}

void cell::trioOfTrios()
{
  // Not Yet Implemented

  if( howManyCouldBes() != 3 ) return;
  int x[3]; // the row of the members of the trio
  int y[3]; // the column of the members of the trio
  int v[3]; // the 3 matching values
  
  // init the arrays
  for( int i=0; i<3; i++ )
    {
      x[i]=y[i]=v[i]=-1;
    }
  
  x[0]=myrow;
  y[0]=mycol;
  {
    int i=0;
    for( int j=0; j<9; j++ )
      {
	if( couldBe[j]>0 )
	  {
	    v[i]=couldBe[j];
	    i++;
	  }
      }
    if(DEBUG==2) cout << "[trioOfTrios] values: " << v[0] << ", " << v[1] << ", and " << v[2] << endl;
  }
  int match=1;
  // now, find another trio in this row that has the same couldbes
  for( int i=0; i<9; i++ )
    {
      if( i!=y[0] )
	{
	  if( puzzle[x[0]][i].howManyCouldBes()==3)
	    {
	      for( int j=0; j<9; j++ )
		{
		  if( puzzle[x[0]][i].couldBe[j] != couldBe[j] )
		    {
		      match=0;
		    }

		}
	      if( match && i!=y[0])
		{

		  x[1]=x[0];
		  y[1]=i;
		  if(DEBUG==6)cout << "[trioOfTrios] first two in row: (" << x[0] << "," << y[0] << ") & (" << x[1] << "," << y[1] << ")" << endl;
		  i=9;
		}
	      match=1;
	    }
	}

    }
  
  for( int i=0; i<9; i++ )
    {
      if( i==y[0] ){}
      else if( i==y[1] ){}
      else
	{
	  if( puzzle[myrow][i].howManyCouldBes() == 3 )
	    {
	      if(  (puzzle[myrow][i].couldIBe(v[0])==1) && (puzzle[myrow][i].couldIBe(v[1])==1) && (puzzle[myrow][i].couldIBe(v[2])==1) )
		{
		  // Then this is a keeper
		  x[2]=myrow;
		  y[2]=i;
		}
	    }
	  else if( puzzle[myrow][i].howManyCouldBes() == 2 )
	    {
	      if( ( (puzzle[myrow][i].couldIBe(v[0])==1) && (puzzle[myrow][i].couldIBe(v[1])==1)) || \
		  ( (puzzle[myrow][i].couldIBe(v[0])==1) && (puzzle[myrow][i].couldIBe(v[2])==1)) || \
		  ( (puzzle[myrow][i].couldIBe(v[1])==1) && (puzzle[myrow][i].couldIBe(v[2])==1)))
		{
		  x[2]=myrow;
		  y[2]=i;
		}
	    }
	}
    }
  if( y[0]>0 && y[1]>0 && y[2]>0 )
    {
      // now remove v[0], v[1], and v[2] from the row (except for the three of the trio)
      if(DEBUG==2)cout << "[trioOfTrios] (row) " << myrow << endl;
      for( int i=0; i<9; i++ )
	{
	  if(i==y[0]){}
	  else if(i==y[1]){}
	  else if(i==y[2]){}
	  else
	    {
	      for( int k=0; k<3; k++ )
		{
		  if( puzzle[myrow][i].couldIBe(v[k]))
		      {
			if((DEBUG==1)||(DEBUG==2)) cout << "[trioOfTrios] (row) (" << myrow << "," << i << ") can't be " << v[k] << endl;
			puzzle[myrow][i].cantBe( v[k] );
			if(DEBUG==2)
			  {
			    cout << "==============" << endl;
			    printPuzzle(1);
			    cout << "==============" << endl;
			  }
		      }
		}
	    }
	}
    }
  /// NOW COLUMNS
  ///
  ///
  
  // init the arrays
  for( int i=0; i<3; i++ )
    {
      x[i]=y[i]=v[i]=-1;
    }
  
  x[0]=myrow;
  y[0]=mycol;
  {
    int i=0;
    for( int j=0; j<9; j++ )
      {
	if( couldBe[j]>0 )
	  {
	    v[i]=couldBe[j];
	    i++;
	  }
      }
    if(DEBUG==2) cout << "[trioOfTrios] (col) values: " << v[0] << ", " << v[1] << ", and " << v[2] << endl;
  }
  match=1;
  // now, find another trio in this column that has the same couldbes
  for( int i=0; i<9; i++ )
    {
      if( i!=y[0] )
	{
	  if( puzzle[i][y[0]].howManyCouldBes()==3)
	    {
	      for( int j=0; j<9; j++ )
		{
		  if( puzzle[i][y[0]].couldBe[j] != couldBe[j] )
		    {
		      match=0;
		    }

		}
	      if( match && i!=x[0])
		{

		  x[1]=i;
		  y[1]=y[0];
		  if(DEBUG==2)cout << "[trioOfTrios] first two in col: (" << x[0] << "," << y[0] << ") & (" << x[1] << "," << y[1] << ")" << endl;
		  i=9;
		}
	      match=1;
	    }
	}

    }
  
  for( int i=0; i<9; i++ )
    {
      if( i==x[0] )
	{
	  // skip already found cell #1
	}
      else if( i==x[1] )
	{
	  // skip already found cell #2
	}
      else
	{
	  if( puzzle[i][mycol].howManyCouldBes() == 3 )
	    {
	      if(  (puzzle[i][mycol].couldIBe(v[0])==1) && (puzzle[i][mycol].couldIBe(v[1])==1) && (puzzle[i][mycol].couldIBe(v[2])==1) )
		{
		  // Then this is a keeper
		  x[2]=i;
		  y[2]=mycol;
		}
	    }
	  else if( puzzle[i][mycol].howManyCouldBes() == 2 )
	    {
	      if( ( (puzzle[i][mycol].couldIBe(v[0])==1) && (puzzle[i][mycol].couldIBe(v[1])==1)) || \
		  ( (puzzle[i][mycol].couldIBe(v[0])==1) && (puzzle[i][mycol].couldIBe(v[2])==1)) || \
		  ( (puzzle[i][mycol].couldIBe(v[1])==1) && (puzzle[i][mycol].couldIBe(v[2])==1)))
		{
		  x[2]=i;
		  y[2]=mycol;
		}
	    }
	}
    }
  if( y[0]>0 && y[1]>0 && y[2]>0 )
    {
      // now remove v[0], v[1], and v[2] from the column (except for the three of the trio)
      if(DEBUG==2)cout << "[trioOfTrios] (col) " << mycol<< endl;
      for( int i=0; i<9; i++ )
	{
	  if( i==x[0] )
	    {

	    }
	  else if( i==x[1] )
	    {

	    }
	  else if( i==x[2] )
	    {

	    }
	  else
	    {
	      for( int k=0; k<3; k++ )
		{
		  if( puzzle[i][mycol].couldIBe(v[k]) )
		      {
			if((DEBUG==1)||(DEBUG==2)) cout << "[trioOfTrios] (col) (" << i << "," << mycol << ") can't be " << v[k] << endl;
			puzzle[i][mycol].cantBe( v[k] );
			if(DEBUG==2)
			  {
			    cout << "==============" << endl;
			    printPuzzle(1);
			    cout << "==============" << endl;
			  }
		      }
		}
	    }
	}
    }



  
  return;
  
}

void cell::trioOfPairs()
{
  if( howManyCouldBes() != 2 ) return;
  // check a row (then a column then a group) for a trio of pairs, if found
  // remove those values from all cells in the row (column of group) - except for
  // the ones who are in the trio of pairs
  int x[3]; // the row of the members of the trio
  int y[3]; // the column of the members of the trio
  int v[3]; // the 3 matching values

  // init the arrays
  for( int i=0; i<3; i++ )
    {
      x[i]=y[i]=v[i]=-1;
    }
  
  x[0]=myrow;
  y[0]=mycol;
  v[0]=minCouldBe();
  v[1]=maxCouldBe();
  if(DEBUG==2) cout << "[trioOfPairs] (row) first pair is at (" << x[0] << "," << y[0] << ")" << endl;

  // now find another one that has v[0] as first value and not v[1] as the second value
  // or that has v[0] as the second value and not v[1] as the first value
  for( int i=0; i<9; i++ )
    {
      // make sure not to double-check my column and that it's only got 2 couldbes
      if( (i!=y[0]) && (puzzle[myrow][i].howManyCouldBes()==2) )
	{
	  // first matches first, second doesn't match second
	  if( (puzzle[myrow][i].couldIBe(v[0]) == 1) && (puzzle[myrow][i].couldIBe(v[1])==0) )
	    {
	      if( puzzle[myrow][i].maxCouldBe() == v[0] )
		{
		  v[2]=puzzle[myrow][i].minCouldBe();
		  x[1]=myrow;
		  y[1]=i;
		  if(DEBUG==2)cout << "[trioOfPairs] (row) second pair is at (" << x[1] << "," << y[1] << ")"<< endl;
		  if(DEBUG==2 && v[0]>0 && v[1] >0 && v[2]>0 ) cout << "[trioOfPairs] (row) The 3 values are: " << v[0] << ", " << v[1] << ", and " << v[2] << endl;
		  i=9;
		}
	      else
		{
		  v[2]=puzzle[myrow][i].maxCouldBe();
		  x[1]=myrow;
		  y[1]=i;
		  if(DEBUG==2)cout << "[trioOfPairs] (row) second pair is at (" << x[1] << "," << y[1] << ")"<< endl;
		  if(DEBUG==2 && v[0]>0 && v[1] >0 && v[2]>0 ) cout << "[trioOfPairs] (row) The 3 values are: " << v[0] << ", " << v[1] << ", and " << v[2] << endl;
		  i=9;
		}
	    }
	  else if( (puzzle[myrow][i].couldIBe(v[1]) ==1) && (puzzle[myrow][i].couldIBe(v[0])==0) )
	    {
	      if( puzzle[myrow][i].maxCouldBe() == v[1] )
		{
		  v[2]=puzzle[myrow][i].minCouldBe();
		  x[1]=myrow;
		  y[1]=i;
		  if(DEBUG==2)cout << "[trioOfPairs] (row) second pair is at (" << x[1] << "," << y[1] << ")"<< endl;
		  if(DEBUG==2 && v[0]>0 && v[1] >0 && v[2]>0 ) cout << "[trioOfPairs] (row) The 3 values are: " << v[0] << ", " << v[1] << ", and " << v[2] << endl;
		  i=9;
		}
	      else
		{
		  v[2]=puzzle[myrow][i].maxCouldBe();
		  x[1]=myrow;
		  y[1]=i;
		  if(DEBUG==2)cout << "[trioOfPairs] (row) second pair is at (" << x[1] << "," << y[1] << ")"<< endl;
		  if(DEBUG==2 && v[0]>0 && v[1] >0 && v[2]>0 ) cout << "[trioOfPairs] (row) The 3 values are: " << v[0] << ", " << v[1] << ", and " << v[2] << endl;
		  i=9;
		}
	    }
	}  
    }
	  
  // now we know the 3 values we're looking for.
  // check for one that could be {v[1],v[2]}
    for( int i=0; i<9; i++ )
    {
      if( i!=y[0] && i!=y[1] ) // Don't check the 2 I've already found
	{
	  if( (puzzle[myrow][i].couldIBe(v[1]) == 1) && (puzzle[myrow][i].couldIBe(v[2])==1) && (puzzle[myrow][i].howManyCouldBes()==2) )
	    {
	      x[2]=myrow;
	      y[2]=i;
	      if(DEBUG==2)cout << "[trioOfPairs] (row) third pair is at (" << myrow << "," << i << ")"<< endl;
	    }
	}
    }
    // if none of these are -1, then I've found a trio of Pairs
    // so remove those values from that row
    if( (y[0]!=-1) && (y[1]!=-1) && (y[2]!=-1))
      {
	if(DEBUG==2)cout << "[trioOfPairs] (row)  (" << x[0] << "," << y[0] << ")(" << x[1] << "," << y[1] << ")(" << x[2] << "," << y[2] << ") could only be " << v[0] << ", " << v[1] << ", or " << v[2] << endl;  
	for( int i=0; i<9; i++ )
	  {
	    if( (i!=y[0]) && (i!=y[1]) && (i!=y[2]))
	      {
		for(int j=0;j<3;j++ )
		  {
		    if( puzzle[myrow][i].couldIBe( v[j] ) == 1 )
		      {
			if((DEBUG==1)||(DEBUG==2))cout << "[trioOfPairs] (row) " << i << " (" << myrow << "," << i << ") can't be a " << v[j] << endl;
			puzzle[myrow][i].cantBe(v[j]);
		      }
		  }
	      }
	  }
      }

    /// Now do columns
    // init the arrays
    for( int i=0; i<3; i++ )
      {
	x[i]=y[i]=v[i]=-1;
      }
    
    x[0]=myrow;
    y[0]=mycol;
    v[0]=minCouldBe();
    v[1]=maxCouldBe();
    if(DEBUG==2) cout << "[trioOfPairs] (col) first pair is at (" << x[0] << "," << y[0] << ")" << endl;

    // now find another one that has v[0] as first value and not v[1] as the second value
    // or that has v[0] as the second value and not v[1] as the first value
    for( int i=0; i<9; i++ )
      {
	// make sure not to double-check my row and that it's only got 2 couldbes
	if( (i!=x[0]) && (puzzle[i][mycol].howManyCouldBes()==2) )
	{
	  // first matches first, second doesn't match second
	  if( (puzzle[i][mycol].minCouldBe() == v[0]) && (puzzle[i][mycol].maxCouldBe()!=v[1]) )
	    {
	      v[2]=puzzle[i][mycol].maxCouldBe();
	      x[1]=i;
	      y[1]=mycol;
	      if(DEBUG==2)cout << "[trioOfPairs] (col) second pair is at (" << x[1] << "," << y[1] << ")"<< endl;

	    }
	  // second matches first, first doesn't match second
	  else if( (puzzle[i][mycol].maxCouldBe() == v[0]) && (puzzle[i][mycol].minCouldBe()!=v[1]) )
	    {
	      v[2] = puzzle[i][mycol].minCouldBe();
	      x[1]=i;
	      y[1]=mycol;
	      if(DEBUG==2)cout << "[trioOfPairs] (col) second pair is at (" << x[1] << "," << y[1] << ")"<< endl;

	    }
	  // first doesn't match first, second matches second
	  else if( (puzzle[i][mycol].minCouldBe() != v[0]) && (puzzle[i][mycol].maxCouldBe()==v[1]) )
	    {
	      v[2] = puzzle[i][mycol].minCouldBe();
	      x[1]=i;
	      y[1]=mycol;
	      if(DEBUG==2)cout << "[trioOfPairs] (col) second pair is at (" << x[1] << "," << y[1] << ")"<< endl;
		  
	    }
	  // second doesn't match first, first matches second
	  else if( (puzzle[i][mycol].maxCouldBe() != v[0]) && (puzzle[i][mycol].minCouldBe()==v[1]) )
	    {
	      v[2] = puzzle[i][mycol].maxCouldBe();
	      x[1]=i;
	      y[1]=mycol;
	      if(DEBUG==2)cout << "[trioOfPairs] (col) second pair is at (" << x[1] << "," << y[1] << ")"<< endl;

	    }
	}
    }
  

  // now we know the 3 values we're looking for.
  // check for one that could be {v[1],v[2]}
    for( int i=0; i<9; i++ )
    {
      if( i!=x[0] && i!=x[1] ) // Don't check the 2 I've already found
	{
	  if( (puzzle[i][mycol].couldIBe(v[1]) == 1) && (puzzle[i][mycol].couldIBe(v[2])==1) && (puzzle[i][mycol].howManyCouldBes()==2) )
	    {
	      x[2]=i;
	      y[2]=mycol;
	      if(DEBUG==2)cout << "[trioOfPairs] (col) third pair is at (" << i << "," << mycol << ")"<< endl;

	    }
	}
    }
    // if none of these are -1, then I've found a trio of Pairs
    // so remove those values from that column
    if( (y[0]!=-1) && (y[1]!=-1) && (y[2]!=-1))
      {
	if(DEBUG==2)cout << "[trioOfPairs] (col)  (" << x[0] << "," << y[0] << ")(" << x[1] << "," << y[1] << ")(" << x[2] << "," << y[2] << ") could only be " << v[0] << ", " << v[1] << ", or " << v[2] << endl;  
	for( int i=0; i<9; i++ )
	  {
	    if( (i!=x[0]) && (i!=x[1]) && (i!=x[2]))
	      {
		for(int j=0;j<3;j++ )
		  {
		    if( puzzle[i][mycol].couldIBe( v[j] ) == 1 )
		      {
			if((DEBUG==1)||(DEBUG==2))cout << "[trioOfPairs] (col) " << i << " (" << myrow << "," << i << ") can't be a " << v[j] << endl;
			puzzle[i][mycol].cantBe(v[j]);
		      }
		  }
	      }
	  }
      }
    // %%%%%%%%%%
    // NOW GROUPS
    // %%%%%%%%%%
    // init the arrays
    for( int i=0; i<3; i++ )
      {
	x[i]=y[i]=v[i]=-1;
      }
    
    x[0]=myrow;
    y[0]=mycol;
    v[0]=minCouldBe();
    v[1]=maxCouldBe();
    if(DEBUG==2)cout << "[trioOfPairs] (grp) found a pair in cell (" << x[0] << "," << y[0] << ")" << endl;    
    // {A,B}, {A,C}, {B,C}

    // now find another one that has v[0] as first value and not v[1] as the second value
    // or that has v[0] as the second value and not v[1] as the first value
    // or v[0] not as the first and v[1] as the second
    // or v[0] not as the second and v[1] as the first
    for( int r=startrow;r<(startrow+3);r++ )
      {
	for( int c=startcol;c<(startcol+3);c++ )
	  {
	    ///////////////////////////
	    if(DEBUG==2)cout << "         [trioOfPairs] (grp) ("<<r<<","<<c<<") checking it for a " << v[0] << " or a " << v[1]  << endl;
	    if(  (r==x[0]) && (c==y[0] ))
	      {
		if(DEBUG==2) cout << "         [trioOfPairs] (grp) skipping (" << r << "," << c << ") becuase it's the first found" << endl;
	      }	     
	    else
	      {
		// only check ones that have 2 couldBes
		if( puzzle[r][c].howManyCouldBes()==2 )
		  {
		    int q=puzzle[r][c].minCouldBe();
		    int w=puzzle[r][c].maxCouldBe();
		    
		    if((q==v[0])&&(w!=v[1]))
		      {
			v[2]=w;
			x[1]=r;
			y[1]=c;
			c=10;r=10;
		      }
		    // second matches first, first doesn't match second
		    // {A,B}, {C,A}		
		    if((w==v[0])&&(q!=v[1]))
		      {
			v[2]=q;
			x[1]=r;
			y[1]=c;	      
			c=10;r=10;
		      }
		    // first doesn't match first, second matches second
		    // {A,B}, {B,C}
		    if((w!=v[0])&&(q==v[1]))
		      {
			v[2]=w;
			x[1]=r;
			y[1]=c;
			c=10;r=10;
		      }
		    // second doesn't match first, first matches second
		    // {A,B},{C,B}
		    if((q!=v[0])&&(w==v[1]))
		      {
			v[2]=q;
			x[1]=r;
			y[1]=c;
			c=10;r=10;
		      }
		  }
		else
		  {
		    if(DEBUG==2) cout << "         [trioOfPairs] (grp) too many could bes in (" << r << "," << c << ")" << endl;
		  }
	      }
	    /////////////////////////// 
	  }
      }

    // haven't found a second one
    if( (x[1]<0) || (y[1]<0) ) return;

    if(DEBUG==2 && v[0]>0 && v[1]>0 && x[0]>=0 && x[1]>=0 && y[0]>=0 && y[1]>=1)cout<< "      [trioOfPairs] (grp) cell 2: (" << x[1] << "," << y[1] << ") could be a " << puzzle[x[1]][y[1]].minCouldBe() << " or a " << puzzle[x[1]][y[1]].maxCouldBe() << endl;

  // now we know the 3 values we're looking for.
  // check for one that could be {v[1],v[2]}
    for( int r=startrow;r<(startrow+3); r++ )
      {
	for( int c=startcol;c<(startcol+3); c++ )
	  {
	    if( r==x[0] && c==y[0] )
	      {
		if(DEBUG==2) cout << "      [trioOfPairs] (grp) NOT checking (" << r << "," << c << ") | howManyCouldBes()=" << puzzle[r][c].howManyCouldBes() << " (orig cell)" << endl;
	      }
	    else if( r==x[1] && c==y[1] )
	      {
		if(DEBUG==2) cout << "      [trioOfPairs] (grp) NOT checking (" << r << "," << c << ") | howManyCouldBes()=" << puzzle[r][c].howManyCouldBes() << " (second cell)" << endl;
	      }
	    else 
	      {
		if(DEBUG==2) cout << "      [trioOfPairs] (grp) checking (" << r << "," << c << ")" << endl;
		
		int t1=((puzzle[r][c].couldIBe(v[1])==1) && (puzzle[r][c].couldIBe(v[2])==1));
		int t2=((puzzle[r][c].couldIBe(v[0])==1) && (puzzle[r][c].couldIBe(v[2])==1));
		int t3=((puzzle[r][c].couldIBe(v[0])==1) && (puzzle[r][c].couldIBe(v[1])==1));
		int t4=puzzle[r][c].howManyCouldBes();
		if( (t1 || t2 || t3) && t4==2 ) 
		  {
		    x[2]=r;
		    y[2]=c;
		    c=10;r=10;
		  }
	      }
	  }
      }

    // haven't found a second one
    if( x[2]<0 || y[2]<0 ) return;
    
    if(DEBUG==2 && v[2]>0)cout<< "      [trioOfPairs] cell 3: (" << x[2] << "," << y[2] << ") could be a " << puzzle[x[2]][y[2]].minCouldBe() << " or a " << puzzle[x[2]][y[2]].maxCouldBe() << endl;

    // if none of these are -1, then I've found a trio of Pairs
    // so remove those values from that GROUP
    if( (y[0]!=-1) && (y[1]!=-1) && (y[2]!=-1))
      {
	if(DEBUG==2)cout << "Found [trioOfPairs] in group.  (" << x[0] << "," << y[0] << ")(" << x[1] << "," << y[1] << ")(" << x[2] << "," << y[2] << ") could only be " << v[0] << ", " << v[1] << ", or " << v[2] << endl;

	for( int r=startrow; r<startrow+3; r++ )
	  {
	    for( int c=startcol; c<startcol+3; c++ )
	      {
		for(int j=0;j<3;j++ )
		  {
		    if( r==x[0] && c==y[0] )
		      {

		      }
		    else if( r==x[1] && c==y[1] )
		      {

		      }
		    else if( r==x[2] && c==y[2] )
		      {

		      }
		    else if(puzzle[r][c].couldIBe( v[j] ) == 1)
		      {
			if((DEBUG==1)||(DEBUG==2))cout << "[trioOfPairs] (grp) (" << r << "," << c << ") can't be a " << v[j] << endl;
			puzzle[r][c].cantBe(v[j]);
		      }
		  }
		
	      }
	  }
      }
    
    return;
}

void cell::dumpCouldBes()
{
  if(DEBUG==2)
    {
      for( int i=0; i<9; i++ )
	{
	  if(couldBe[i] > 0) cout << couldBe[i];
	}
      cout << ",";
      return;
    }
  
  if( howManyCouldBes() > 1 )
  {
    cout << "(" << myrow << "," << mycol << "): ";
    for( int i=0; i<9; i++ )
      {
	if(couldBe[i] > 0) cout << couldBe[i] << " ";
      }
    cout << endl;
  }
}
void cell::soleCouldBe()
{
  if( (howManyCouldBes() == 1) && (getValue()==0))
    {
      if((DEBUG==1)||(DEBUG==2))cout << "[soleCouldBe] Setting (" << myrow << "," << mycol << ") to " << maxCouldBe() << endl;
      setValue(maxCouldBe());
    }
  return;
}

void cell::lonely()
{
  // If I'm the only one in my row or column that could be a value... then I must be it.
  int count=0;
  for( int i=0; i<9; i++ )
    {
      int m=couldBe[i];
      if( m!= 0 )
	{
	  for( int j=0; j<9; j++ )
	    {
	      if( j!=mycol )
		{
		  if( puzzle[myrow][j].couldIBe(m)==1 )
		    {
		      count++;
		    }
		}
	    }
	  if( count == 0 )
	    {
	      if( getValue() == 0 )
		{
		  if(DEBUG==2) cout << "(" << myrow << "," << mycol << ") = " << m << " is [lonely] (row)" << endl;
		  setValue(m);
		  // now make sure that nothing in this column can be this value
		  for( int j=0; j<9; j++ )
		    {
		      if( j!=myrow )
			{
			  if( puzzle[j][mycol].couldIBe(m)==1 )
			    {
			      if((DEBUG==1)||(DEBUG==2)) cout << "[lonely] (row) (" << j << "," << mycol << ") can't be a " << m << endl;
			      puzzle[j][mycol].cantBe(m);
			    }
			}
		    }
		  return;
		}
	    }
	  count=0;
	}
    }
  count=0;

  // now columns
  for( int i=0; i<9; i++ )
    {
      int m=couldBe[i];
      if( m!= 0 )
	{
	  for( int j=0; j<9; j++ )
	    {
	      if( j!=mycol )
		{
		  if( puzzle[j][mycol].couldIBe(m)==1 )
		    {
		      count++;
		    }
		}
	    }
	  if( count == 0 )
	    {
	      if( getValue() == 0 )
		{
		  if(DEBUG==2) cout << "(" << myrow << "," << mycol << ") = " << m << " is [lonely] (col)" << endl;
		  setValue(m);
		  // now remove this value from the row
		  for( int j=0; j<9; j++  )
		    {
		      if( j!= mycol )
			{
			  if( puzzle[myrow][j].couldIBe(m)==1)
			    {
			      if((DEBUG==1)||(DEBUG==2)) cout << "[lonely] (col) ("<< myrow << "," << j << ") can't be a " << m << endl;
			      puzzle[myrow][j].cantBe(m);
			    }
			}

		    }
		  return;
		}
	    }
	  count=0;
	}
    }

  
}
void cell::exclusion()
{
  // check the group for a matching number in their couldbes
  int count=0;
  int mycouldbe=0;
  // now find if I have a "couldbe" that is unique to my ROW in my group
  for( int i=0; i<9; i++ )
    {
      // as long as we're talking a value other than 0 and a cell that isn't already set
      if( (couldBe[i] > 0) && (getValue() == 0))
	{
	  for( int r=startrow;r<startrow+3;r++ )
	    {
	      for( int c=startcol;c<startcol+3;c++ )
		{
		  // as long as it's not my row
		  if( r!=myrow )
		    {
		      if ( puzzle[r][c].couldBe[i]==couldBe[i] )
			{
			  // it's not unique
			  count++;
			  c=startcol+3;
			  r=startrow+3;
			}
		      else
			{
			  mycouldbe=couldBe[i];
			}
		    }
		}
	    }
	  if(count==0)
	    {
	      {
		// it IS unique
		// now remove it from all of my row except from my group
		for( int j=0; j<9; j++ )
		  {
		    if((( j<startcol ) || ( j>startcol+2 )) && (puzzle[myrow][j].couldIBe(mycouldbe)==1))
		      {
			if((DEBUG==1)||(DEBUG==2))cout << "[exclusion] (row) (" << myrow << "," << j << ") can't be a " << mycouldbe << endl;
			puzzle[myrow][j].cantBe(mycouldbe);
		      }
		  }
		return;
	      }
	    }
	  else
	    {
	      mycouldbe=0;
	    }
	}
      mycouldbe=0;
      count=0;
    }
  count=0;
  mycouldbe=0;
  
  
  // now find if I have a "couldbe" that is unique to my COLUMN in my group
  for( int i=0; i<9; i++ )
    {
      // as long as we're talking a value other than 0 and a cell that isn't already set
      if( (couldBe[i] > 0) && (getValue() == 0))
	{
	  for( int r=startrow;r<startrow+3;r++ )
	    {
	      for( int c=startcol;c<startcol+3;c++ )
		{
		  // as long as it's not my COLUMN
		  if( c!=mycol )
		    {
		      if ( puzzle[r][c].couldBe[i]==couldBe[i] )
			{
			  // it's not unique
			  count++;
			  c=startcol+3;
			  r=startrow+3;
			}
		      else
			{
			  mycouldbe=couldBe[i];
			}
		    }
		}
	    }
	  if(count==0)
	    {
	      {
		// it IS unique
		// now remove it from all of my column except from my group
		for( int j=0; j<9; j++ )
		  {
		    if((( j<startrow ) || ( j>startrow+2 )) && (puzzle[j][mycol].couldIBe(mycouldbe)==1))
		      {
			//puzzle[myrow][j].couldBe[mycouldbe-1]=0;
			if((DEBUG==1)||(DEBUG==2))cout << "[exclusion] (col) (" << j << "," << mycol << ") can't be a " << mycouldbe << endl;
			
			puzzle[j][mycol].cantBe(mycouldbe);
			  
		      }
		  }
		return;
	      }
	      
	    }
	  else
	    {
	      mycouldbe=0;
	    }
	}
      mycouldbe=0;
      count=0;
    }
  return;
}

void cell::pairs()
{
  int x[2];
  int y[2];

  int count=0;
  if( howManyCouldBes() != 2 ) return;
  for( int i=0; i<9; i++ )
    {
      if( couldBe[i] > 0 )
	{
	  x[count++]=couldBe[i];
	}
    }
  
  // now x[0] and x[1] contain the values of the pair

  // check the row for a matching pair
  count=0;
  for( int i=0; i<9; i++ )
    {
      if( puzzle[myrow][i].howManyCouldBes() == 2 )
	{
	  // then it has a pair... is it the same pair?
	  for( int j=0;j<9;j++ )
	    {
	      if( ( puzzle[myrow][i].couldBe[j] != 0 ) && ( i != mycol ))
		{
		  y[count++]=puzzle[myrow][i].couldBe[j];
		}
	    }
	  if( (x[0] == y[0]) && (x[1] == y[1] ))
	    {
	      int skipcol1 = mycol;
	      int skipcol2 = puzzle[myrow][i].mycol;
	      for( int h=0; h<9; h++ )
		{

		  if( (h!=skipcol1) && (h!=skipcol2) && (skipcol1!=skipcol2) &&  ( (puzzle[myrow][h].couldIBe(x[0])==1) || (puzzle[myrow][h].couldIBe(x[1]) == 1)) )

		    {
		      if((DEBUG==1)||(DEBUG==2))cout << "[pairs] (row) (" << myrow << "," << h << ") can't be a " << x[0] << " or " << x[1] << endl;
		      puzzle[myrow][h].cantBe(x[0]);
		      puzzle[myrow][h].cantBe(x[1]);
		    }
		}
	    }
	}
      count=0;
    }


  // check the column for a matching pair
  count=0;
  for( int i=0; i<9; i++ )
    {
      if( puzzle[i][mycol].howManyCouldBes() == 2 )
	{
	  // then it has a pair... is it the same pair?
	  for( int j=0;j<9;j++ )
	    {
	      if( ( puzzle[i][mycol].couldBe[j] != 0 ) && ( i != myrow ))
		{
		  y[count++]=puzzle[i][mycol].couldBe[j];
		}
	    }
	  if( (x[0] == y[0]) && (x[1] == y[1] ))
	    {
	      int skiprow1 = myrow;
	      int skiprow2 = puzzle[i][mycol].myrow;
	      for( int h=0; h<9; h++ )
		{
		  if(  (h!=skiprow1) && (h!=skiprow2) && (skiprow1!=skiprow2) && ((puzzle[h][mycol].couldIBe(x[0])==1) || (puzzle[h][mycol].couldIBe(x[1])==1)) )
		    {
		      if((DEBUG==1)||(DEBUG==2))cout << "[pairs] (col) (" << h << "," << mycol << ") can't be a " << x[0] << " or " << x[1] << endl;
		      puzzle[h][mycol].cantBe(x[0]);
		      puzzle[h][mycol].cantBe(x[1]);
		    }
		}
	    }
	}
      count=0;
    }
  // %%%%%%%%%%%%%%
  // check the group for a matching pair
  // %%%%%%%%%%%%%%
 
  count=0;
  for( int h=0; h<2; h++ )
    {
      y[h]=0;
    }
  int mr=-1;
  int mc=-1;
  int found=0;
  for( int r=startrow; r<(startrow+3); r++ )
    {
      for( int c=startcol; c<(startcol+3); c++ )
	{
	  if( (r==myrow) && (c==mycol) )
	    {
	      if(DEBUG==2) cout << "[pairs] (grp) skipping: (" << r << "," << c << ")" << endl;	      
	    }
	  else if( puzzle[r][c].howManyCouldBes()==2 )
	    {
	      count=0;
	      // it's not me and it has a pair
	      for( int i=0; i<9; i++ )
		{
		  if( puzzle[r][c].couldBe[i] > 0 )
		    {
		      y[count++]=puzzle[r][c].couldBe[i];
		    }
		}

	      if( (x[0] == y[0]) && (x[1]==y[1]))
		{
		  if(DEBUG==2) cout << "[pairs] (grp) Found matching pair: (" << r << "," << c << ") = (" << myrow << "," << mycol << ")'s couldBes... "<< x[0] << " and " << x[1] << endl;
	      
		  // then we have a matching pair
		  mr=r;
		  mc=c;
		  r=20;
		  c=20;
		  found=1;
		  break;
		}
	    }
	}
    }

  if(found==1 )
    {
      for( int r=startrow; r<(startrow+3); r++ )
	{
	  for( int c=startcol; c<(startcol+3); c++ )
	    {
	      if( (r==myrow) && (c==mycol ) )
		{
		  if(DEBUG==2) cout << "[pairs] (grp) skipping: (" << r << "," << c << ")" << endl;
		}
	      else if( (r==mr) && (c==mc) )
		{
		  if(DEBUG==2) cout << "[pairs] (grp) skipping: (" << r << "," << c << ")" << endl;
		}
	      else 
		{
		  if( puzzle[r][c].couldIBe(x[0])==1)
		    {
		      if((DEBUG==1)||(DEBUG==2))cout << "[pairs] (grp) (" << r << "," << c << ") can't be a " << x[0] << endl;
		      puzzle[r][c].cantBe( x[0] );
		    }
		    if( puzzle[r][c].couldIBe(x[1])==1)
		    {
		      if((DEBUG==1)||(DEBUG==2))cout << "[pairs] (grp) (" << r << "," << c << ") can't be a " << x[1] << endl;
		      puzzle[r][c].cantBe( x[1] );
		    }
		}
	    }
	}
    }
  return;
      
  //////
  for( int r=startrow; r<startrow+3; r++ )
    {
      for( int c=startcol; c<startcol+3; c++ )
	{
	  y[0]=0;
	  y[1]=0;
	  if( (r!=myrow) && (c!=mycol) && (puzzle[r][c].howManyCouldBes()==2) )
	    {
	      count=0;
	      // it's not me and it has a pair
	      for( int i=0; i<9; i++ )
		{
		  if( puzzle[r][c].couldBe[i] > 0 )
		    {
		      y[count++]=puzzle[r][c].couldBe[i];
		    }
		}
	      cout << "[pairs] (grp) (" << r << "," << c << ") has " << count << " couldBes... "<< y[0] << " and " << y[1] << endl;
	      if( (x[0] == y[0]) && (x[1] == y[1]) )
		{
		  if(DEBUG==2) cout << "[pairs] (grp) ... and the 2 couldBes match with (" << myrow << "," << mycol << "): " << x[0] << " and " << x[1]  << endl;
		  // the pair matches so remove those 2 from every cell in the group except these 2
		  for( int r1=startrow;r1<startrow+3;r1++ )
		    {
		      for( int c1=startcol;c1<startcol+3;c1++ )
			{
			  if( (r1 == r) && (c1==c) )
			    {
			      if(DEBUG==2) cout << "[pairs] (grp) skipping: (" << r1 << "," << c1 << ")" << endl;
			    }
			  else if( (r1==myrow) && (c1 == mycol ))
			    {
			      if(DEBUG==2) cout << "[pairs] (grp) skipping: (" << r1 << "," << c1 << ")" << endl;
			    }
			  else 
			    {
			      if( puzzle[r1][c1].couldIBe(x[0])==1)
				{
				  if((DEBUG==1)||(DEBUG==2))cout << "[pairs] (grp) (" << r1 << "," << c1 << ") can't be a " << x[0] << endl;
				  puzzle[r1][c1].cantBe( x[0] );
				}
			      if( puzzle[r1][c1].couldIBe(x[1])==1)
				{
				  if((DEBUG==1)||(DEBUG==2))cout << "[pairs] (grp) (" << r1 << "," << c1 << ") can't be a " << x[1] << endl;
				  puzzle[r1][c1].cantBe( x[1] );
				}
			    }
			}
		      
		    }
		  //		   r=10;c=10;
		}
	    }
	}
      count=0;
    }
}

int cell::couldIBe(int x)
{
  if( x==0 ) return -1;
  int ret=0;
  for( int i=0;i<9;i++ )
    {
      if( couldBe[i] == x ) ret=1;
    }
  return(ret);
}
 
int cell::minCouldBe()
{
  int min=0;
  for( int i=0; i<9; i++ )
    {
      
      if( couldBe[i] > min )
	{
	  min=couldBe[i];
	  i=10;
	  break;
	}
    }
  
  if( min==0 ) min=-1;
  return( min );
}
 
int cell::maxCouldBe()
{
  int max=0;
  //if( howManyCouldBes() > 1 ) return(-1);
  for( int i=8; i>=0; i-- )
    {
      if( couldBe[i] > max )
	{
	  max=couldBe[i];
	  i=0;
	  break;
	}
    }

  return(max);
}

int cell::getGroup()
{
  return( mySubGroup );
}
  
void cell::setGroup(int g)
{
  mySubGroup=g;
}
void cell::setRC(int x, int y)
{
  myrow=x;
  mycol=y;
  x=floor(x/3);
  y=floor(y/3);
  switch(x)
    {
    case 0:
      switch( y )
	{
	case 0:
	  setGroup(1);
	  startrow=0;
	  startcol=0;
	  break;
	case 1:
	  setGroup(2);
	  startrow=0;
	  startcol=3;
	  break;
	case 2:
	  setGroup(3);
	  startrow=0;
	  startcol=6;
	  break;
	}
      break;
    case 1:
      switch( y )
	{
	case 0:
	  setGroup(4);
	  startrow=3;
	  startcol=0;
	  break;
	case 1:
	  setGroup(5);
	  startrow=3;
	  startcol=3;
	  break;
	case 2:
	  setGroup(6);
	  startrow=3;
	  startcol=6;
	  break;
	}
      break;

    case 2:
      switch( y )
	{
	case 0:
	  setGroup(7);
	  startrow=6;
	  startcol=0;
	  break;
	case 1:
	  setGroup(8);
	  startrow=6;
	  startcol=3;
	  break;
	case 2:
	  setGroup(9);
	  startrow=6;
	  startcol=6;
	  break;
	}
    }
}
void cell::uniqueInRow()
{
  int count=0;
  for( int i=0; i<9; i++ )
    {
      for( int c=0; c<9; c++ )
	{
	  if( (couldBe[i] > 0) && (couldBe[i]==puzzle[myrow][c].couldBe[i] ) )
	    {
	      count++;
	    }
	}
      if( (count == 1) && (getValue() ==0) )
	{
	  if((DEBUG==1)||(DEBUG==2))cout << "[uniqueInRow] Setting (" << myrow << "," << mycol << ") to " << couldBe[i] << endl;
				
	  setValue( couldBe[i] );
	}
    }
}
void cell::uniqueInColumn()
{
  int count=0;
  for( int i=0; i<9; i++ )
    {
      for( int r=0; r<9; r++ )
	{
	  if( (couldBe[i] > 0) && (couldBe[i]==puzzle[r][mycol].couldBe[i]) )
	    {
	      count++;
	    }
	}
      if( (count == 1) && (getValue() ==0 )  )
	{
	  if((DEBUG==1)||(DEBUG==2))cout << "[uniqueInColumn] Setting (" << myrow << "," << mycol << ") to " << couldBe[i] << endl;	  
	  setValue( couldBe[i] );
	}
    }
}


void cell::uniqueInGroup()
{
  int count=0;
  
  for( int i=0; i<9; i++ )
    {
      for( int row=startrow; row<startrow+3; row++ )
	{
	  for( int col=startcol; col<startcol+3; col++ )
	    {
	      /* %%%% */
	      if( (couldBe[i]>0) && (puzzle[row][col].couldBe[i] == couldBe[i]))
		{
		  count++;
		}
	    }
	}
      if( (count==1) && (couldBe[i]>0) && (getValue()==0))
	{
	  // Then it's unique 
	  if((DEBUG==1)||(DEBUG==2))cout << "[uniqueInGroup] Setting (" << myrow << "," << mycol << ") to " << couldBe[i] << endl;
		      
	  setValue( couldBe[i] );
	  return;
	}
      else
	{
	  count=0;
	}
    }
  return;
}

void cell::cantBe(int x)
{
  if(couldBe[x-1]==x)couldBe[x-1]=0;
}

void cell::initCouldBes()
{
  for( int i=0; i<9; i++ )
    {
      couldBe[i]=i+1;
    }
}

int cell::howManyCouldBes()
{
  int count=0;
  for( int i=0; i<9; i++ )
    {
      if( couldBe[i] > 0 )
	{
	  count++;
	}    
    }
  return( count );
}


void cell::setValue(int x)
{
  state++; // change state
  value=x;
  P[myrow][mycol]=1;
  for( int i=0; i<9; i++ )
    {
      couldBe[i]=0;
    }
  couldBe[x-1]=x;
  
}

int cell::getValue()
{
  return( value );
}

int cell::checkRow()
{
  for( int i=0; i<9; i++ )
    {
      int x=puzzle[myrow][i].getValue();

      // %%%%%%
      if( (x>0) && (i!=mycol) && (howManyCouldBes()>1) && (couldIBe(x)==1) )
	{
	  // Then remove that value from my could bes
	  if((DEBUG==1)||(DEBUG==2))cout << "[checkRow] (" << myrow << "," << mycol << ") can't be a " << x << endl;
	  cantBe(x);
	  if( (howManyCouldBes() == 1) && (getValue()==0))
	    {
	      if((DEBUG==1)||(DEBUG==2))cout << "[checkRow] Setting (" << myrow << "," << mycol << ") to " << maxCouldBe() << endl;
	      setValue( maxCouldBe() );
	    }
	}
    }

  return(1);
}

int cell::checkColumn()
{
 for( int i=0; i<9; i++ )
    {
      int x=puzzle[i][mycol].getValue();
      
      if( (x>0) && (i!=myrow) && (howManyCouldBes()>1) && (couldIBe(x)==1))
	{
	  // Then remove that value from my could bes
	  if((DEBUG==1)||(DEBUG==2))cout << "[checkColumn] (" << myrow << "," << mycol << ") can't be a " << x << endl;

	  cantBe(x);
	  if( (howManyCouldBes() == 1) && (getValue()==0 ))
	    {
	      if((DEBUG==1)||(DEBUG==2))cout << "[checkColumn] Setting (" << myrow << "," << mycol << ") to " << maxCouldBe() << endl;

	      setValue( maxCouldBe() );
	    }
	  
	}
    }
 return(1);
}
int cell::checkGroup()
{
  int myg=getGroup();
  
  for( int r=0; r<9; r++ )
    {
      for( int c=0; c<9; c++ )
	{
	  if( myg==puzzle[r][c].getGroup() )
	    {
	      // Then it's in the same group
	      int x=puzzle[r][c].getValue();
	      if( (x > 0) && (howManyCouldBes() > 1) && (couldIBe(x)==1))
		{
		  if((DEBUG==1)||(DEBUG==2))cout << "[checkGroup] (" << myrow << "," << mycol << ") can't be a " << x << endl;
		  cantBe(x);
		  if( (howManyCouldBes() == 1) && ( getValue() == 1))
		    {
		      if((DEBUG==1)||(DEBUG==2))cout << "[checkGroup] Setting (" << myrow << "," << mycol << ") to " << maxCouldBe() << endl;
			     
		      setValue( maxCouldBe() );
		    }
		}
	      
	    }

	}

    }
  return(1);
}

void sweep()
{
  
  for( int r=0; r<9; r++ )
    {
      for( int c=0; c<9; c++ )
	{
	  puzzle[r][c].checkRow();
	  puzzle[r][c].checkColumn();
	  puzzle[r][c].checkGroup();
	}
    }
  for( int r=0; r<9; r++ )
    {
      for( int c=0; c<9; c++ )
	{
	  puzzle[r][c].soleCouldBe();
	  puzzle[r][c].pairs();
	  puzzle[r][c].noFourthCorner();
	  puzzle[r][c].exclusion();
	  puzzle[r][c].lonely();
	  puzzle[r][c].uniqueInRow();
	  puzzle[r][c].uniqueInColumn();
	  puzzle[r][c].uniqueInGroup();
	  puzzle[r][c].trioOfPairs(); 
	  puzzle[r][c].trioOfTrios();
	  puzzle[r][c].emptyRectangle();
	  puzzle[r][c].boxLineRedux();
	  
	}
    }
}

void justValues()
{
  for( int r=0; r<9; r++ )
    {
      for( int c=0; c<9; c++ )
	{
	  cout << puzzle[r][c].getValue() << ",";
	}
    }
  return;
}

void printPuzzle(int which)
{
  cout << endl;
  int start=0;
  int finish;
  int a,b,c;
  while( start < 9 )
    {
      finish=start+3;
      for( int row=start; row<finish; row++ )
	{
	  for( int col=0; col<9; col+=3 )
	    {
	      if( which == 1 )
		{
		  a=puzzle[row][col].howManyCouldBes();
		  b=puzzle[row][col+1].howManyCouldBes();
		  c=puzzle[row][col+2].howManyCouldBes();
		}
	      else 
		{
		  a=puzzle[row][col].getValue();
		  b=puzzle[row][col+1].getValue();
		  c=puzzle[row][col+2].getValue();
		}
	      if( a > 0 )
		{
		  cout << a;
		}
	      else
		{
		  cout << " ";
		}
	      cout << " ";
	      if( b > 0 )
		{
		  cout << b;
		}
	      else
		{
		  cout << " ";
		}
	      cout << " ";
	      if( c > 0 )
		{
		  cout << c;
		}
	      else
		{
		  cout << " ";
		}
	      if( col<6 ) cout << " | ";
	    }
	  cout << endl;
	}
      
      if( start < 6 ) cout << "------+-------+-------" << endl;
      start+=3;
    }
  cout << endl;

}
// Global

void setCell( int row, int col, int v )
{
  puzzle[row][col].setValue(v);
}
// -------------------------------------------------------
int main()
{
  // initialize the puzzle with file
  for( int row=0; row<9; row++ )
    {
      for( int col=0; col<9; col++ )
	{
	  //cin >> P[row][col]; 
	}

    }
  
  for( int row=0; row<9; row++ )
    {
      for( int col=0; col<9; col++ )
	{
	  puzzle[row][col].initCouldBes();
	  if( P[row][col] > 0 ) puzzle[row][col].setValue(P[row][col]);
	  if( P[row][col] > 0 ) P[row][col]=1;
	  puzzle[row][col].setRC(row,col);
	}
    }

  if(DEBUG==4)
    {
      justValues();
    }
  // check start score
  for( int r=0; r<9; r++ )
    {
      for( int c=0; c<9; c++ )
	{
	  if( P[r][c]==1 ) startscore++;
	}

    }

  
  int v=0;
  int SOLVED=0;
  int iterations=0;
  int brk=0;
  if((DEBUG!=4)&&(DEBUG!=5)&&(DEBUG!=10))printPuzzle(0);
  while( (verifyWin()==0) && (iterations < MAXITERATIONS) && (brk==0) )
    {
      _oldstate=state;

      sweep();

      if( state==_oldstate )
	{
	  cout << "No change in state." << endl;
	  statecount++;
	  if( statecount == 3 )
	    {
	      brk=1;
	      iterations=MAXITERATIONS-1;
	    }
	}
      else
	{
	  statecount=0;
	}
      	    
      int checkprod=P[0][0];
      // Check For Solution
      for( int e=0; e<9; e++ )
	{
	  for( int f=0; f<9; f++ )
	    {
	      checkprod*=P[e][f];
	    }
	}
      iterations++;
      if( checkprod == 1 ) SOLVED=1;
    }
  

  if(iterations<MAXITERATIONS)
    {
      for( int r=0; r<9; r++ )
	{
	  for( int c=0; c<9; c++ )
	    {
	      puzzle[r][c].setValue( puzzle[r][c].maxCouldBe() );
	    }
	}
    }
  else
    {
      if((DEBUG!=4)&&(DEBUG!=5)&&(DEBUG!=10)) cout << "Not solved yet." << endl;
    }
  cout << endl;

  if((DEBUG==1)||(DEBUG==2))
    {
      for( int r=0; r<9; r++ )
	{
	  for( int c=0; c<9; c++ )
	    {
	      puzzle[r][c].dumpCouldBes();
	    }
	}
    }
  
  if((DEBUG!=4)&&(DEBUG!=5)&&(DEBUG!=10)) printPuzzle(0);

  // check score
  for( int r=0; r<9; r++ )
    {
      for( int c=0; c<9; c++ )
	{
	  if( P[r][c]==1 ) score++;
	}

    }
  if ( (DEBUG==2) || (DEBUG==3)) printPuzzle(1);
  if (verifyWin())
    {
      if(DEBUG==5)
	{
	  justValues();
	  cout << iterations << endl;
	}
      else
	{
	  if((DEBUG!=4)&&(DEBUG!=5)&&(DEBUG!=10))
	    {
	      cout << "Solved!" << endl;
	      //printRaw();
	    }
	}
    }
  else
    {
      cout << "Solution Not Found" << endl;
    }
  
  if((DEBUG!=4)&&(DEBUG!=5)&&(DEBUG!=10)) cout << "Iterations: " << iterations << "\tScore: " << round(100*score/81) << "%      (started at: " << round(100*startscore/81) << "%)" << endl;
  if(DEBUG==10) printArray();
  return( 0 );
}
